<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Whispeer Control Panel</title>
  <style>
    :root {
      --primary-color: #03a9f4;
      --primary-dark: #0288d1;
      --secondary-color: #ff9800;
      --background-color: #fafafa;
      --surface-color: #ffffff;
      --text-primary: #212121;
      --text-secondary: #757575;
      --border-color: #e0e0e0;
      --shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* Dark theme - follows system preference automatically */
    @media (prefers-color-scheme: dark) {
      :root {
        --primary-color: #4fc3f7;
        --primary-dark: #29b6f6;
        --secondary-color: #ffb74d;
        --background-color: #121212;
        --surface-color: #1e1e1e;
        --text-primary: #ffffff;
        --text-secondary: #b0b0b0;
        --border-color: #333333;
        --shadow: 0 2px 4px rgba(0,0,0,0.3);
      }
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background-color: var(--background-color);
      color: var(--text-primary);
      line-height: 1.6;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      background: var(--surface-color);
      border: 1px solid var(--border-color);
      padding: 16px 24px;
      border-radius: 8px;
      margin-bottom: 24px;
      box-shadow: var(--shadow);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header h1 {
      font-size: 1.8rem;
      font-weight: 400;
      margin: 0;
      color: var(--text-primary);
    }

    .header-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .btn {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-secondary {
      background: var(--secondary-color);
    }

    .btn-secondary:hover {
      background: #f57c00;
    }

    .btn-small {
      padding: 8px 16px;
      font-size: 0.8rem;
      border-radius: 4px;
    }

    .btn-outlined {
      background: transparent;
      color: var(--primary-color);
      border: 2px solid var(--primary-color);
      box-shadow: none;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .btn-outlined:hover {
      background: var(--primary-color);
      color: white;
    }

    #languageSelector {
      background: var(--primary-color);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 500;
      text-transform: none;
      letter-spacing: normal;
    }

    #languageSelector:hover {
      background: var(--primary-dark);
    }

    .devices-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }

    .device-card {
      background: var(--surface-color);
      border-radius: 8px;
      padding: 20px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
    }

    .add-device-card {
      background: var(--surface-color);
      border-radius: 8px;
      padding: 20px;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      border: 2px dashed var(--border-color);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 120px;
      text-align: center;
      color: var(--text-secondary);
    }

    .add-device-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border-color: var(--primary-color);
      background: var(--background-color);
    }

    /* Dark mode specific hover effect */
    @media (prefers-color-scheme: dark) {
      .add-device-card:hover {
        background: #2a2a2a;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      }
    }

    .add-device-icon {
      font-size: 3rem;
      margin-bottom: 12px;
      color: var(--primary-color);
    }

    .device-commands {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .device-commands .btn {
      flex: 1;
      min-width: fit-content;
      text-align: center;
      white-space: nowrap;
    }

    .device-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 16px;
    }

    .device-header-right {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
    }

    .device-name {
      font-size: 1.2rem;
      font-weight: 500;
      color: var(--text-primary);
    }

    .device-type-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .type-ble {
      background: #e3f2fd;
      color: #1976d2;
    }

    .type-rf {
      background: #f3e5f5;
      color: #7b1fa2;
    }

    .type-ir {
      background: #fff3e0;
      color: #f57c00;
    }

    .device-info {
      color: var(--text-secondary);
      font-size: 0.9rem;
      margin-bottom: 16px;
    }

    .device-actions {
      display: flex;
      gap: 8px;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: var(--text-secondary);
    }

    .loading::after {
      content: '';
      width: 40px;
      height: 40px;
      border: 3px solid var(--border-color);
      border-top: 3px solid var(--primary-color);
      border-radius: 50%;
      display: inline-block;
      animation: spin 1s linear infinite;
      margin-top: 16px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }

    .empty-state h3 {
      font-size: 1.5rem;
      margin-bottom: 16px;
      color: var(--text-primary);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
    }

    .modal-content {
      background: var(--surface-color);
      margin: 2% auto;
      padding: 24px;
      border-radius: 8px;
      width: calc(100% - 40px);
      max-width: calc(100vw - 40px);
      min-width: 300px;
      height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-title {
      font-size: 1.5rem;
      font-weight: 500;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-secondary);
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--text-primary);
    }

    /* Unify all modal input styles, including command add/edit fields */
    .form-input, .form-select, .command-name, .command-code {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--border-color);
      border-radius: 6px;
      font-size: 0.9rem;
      transition: border-color 0.3s ease;
      background: var(--surface-color);
      color: var(--text-primary);
      box-sizing: border-box;
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    .form-input:focus, .form-select:focus, .command-name:focus, .command-code:focus {
      outline: none;
      border-color: var(--primary-color);
    }
    .command-name {
      min-width: 120px;
      max-width: 150px;
      font-weight: 500;
      border-radius: 6px;
      background: var(--surface-color);
      font-size: 0.9rem;
    }
    /* Add command form inputs */
    #addCommandForm input[type="text"] {
      border-radius: 6px;
      background: var(--surface-color);
      font-size: 0.9rem;
      color: var(--text-primary);
      border: 2px solid var(--border-color);
      padding: 12px;
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    #addCommandForm input[type="text"]:focus {
      border-color: var(--primary-color);
      outline: none;
    }

    .commands-section {
      margin-top: 30px;
      padding: 0;
      background: transparent;
      border-radius: 0;
      border-top: 1px solid var(--border-color);
      padding-top: 20px;
    }

    .commands-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .commands-list {
      /* max-height: 40vh; */
      overflow-y: auto;
    }

    .command-item {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 8px 12px;
      background: var(--surface-color);
      border-radius: 4px;
      margin-bottom: 8px;
      border: 1px solid var(--border-color);
    }

    .command-name {
      font-weight: 500;
      min-width: 120px;
    }

    .command-code {
      font-family: monospace;
      font-size: 0.8rem;
      color: var(--text-secondary);
      flex: 1;
      /* padding: 4px 8px; */
      border-radius: 3px;
      word-break: break-all;
    }

    .command-actions {
      display: flex;
      gap: 4px;
    }

    .btn-tiny {
      padding: 4px 8px;
      font-size: 0.7rem;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-edit {
      background: var(--secondary-color);
      color: white;
    }

    .btn-delete, .command-inline-btn.delete, .btn-remove {
      background: transparent;
      color: #f44336;
      border: 2px solid #f44336;
      font-weight: 500;
      box-shadow: none;
      transition: all 0.2s ease;
    }
    .btn-delete:hover, .command-inline-btn.delete:hover, .btn-remove:hover {
      background: #f44336;
      color: white;
    }

    .btn-test {
      background: var(--primary-color);
      color: white;
    }

    .command-form {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
    }

    .command-form input {
      flex: 1;
    }

    .command-form input:first-child {
      max-width: 150px;
    }

    .pill-edit {
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 4px 16px;
      font-size: 0.8rem;
      font-weight: 500;
      margin-left: 8px;
      cursor: pointer;
      transition: background 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }
    .pill-edit:hover {
      background: var(--primary-dark);
    }

    /* New Command UI Styles */
    .command-group {
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .command-group-header {
      background: var(--surface-color);
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .command-group-header:hover {
      background: var(--background-color);
    }

    .command-group-title {
      font-weight: 500;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .command-group-count {
      background: var(--primary-color);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 500;
    }

    .command-group-chevron {
      transition: transform 0.3s ease;
      color: var(--text-secondary);
    }

    .command-group.collapsed .command-group-chevron {
      transform: rotate(-90deg);
    }

    .command-group-content {
      padding: 16px;
      background: var(--background-color);
    }

    .command-group.collapsed .command-group-content {
      display: none;
    }

    .command-preview {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }

    .command-btn-preview {
      padding: 8px 16px;
      border: none;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* New inline command form styles */
    .command-inline-form {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      background: var(--background-color);
      border: 1px solid var(--border-color);
      border-radius: 6px 6px 0 0;
      margin-bottom: 0;
      flex-wrap: wrap;
    }

    /* Command container styles */
    .command-container {
      border: 1px solid var(--border-color);
      border-radius: 6px;
      margin-bottom: 12px;
      background: var(--background-color);
      overflow: hidden;
    }

    .command-container .command-inline-form {
      border: none;
      border-radius: 0;
      margin-bottom: 0;
    }

    .command-options-section {
      padding: 16px;
      background: var(--background-color);
      border-top: 1px solid var(--border-color);
    }

    .option-field {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }

    .option-field input:first-child {
      flex: 1; /* Name field takes 1/3 */
    }

    .option-field input:nth-child(2) {
      flex: 2; /* Code field takes 2/3 */
    }

    .input-group {
      display: flex;
      align-items: stretch;
      flex: 2; /* Same space as code field */
    }

    .input-group-prepend {
      display: flex;
    }

    .input-group-text {
      background: linear-gradient(135deg, var(--accent-color) 0%, rgba(3, 169, 244, 0.8) 100%);
      color: white;
      border: 1px solid var(--border-color);
      border-right: none;
      padding: 6px 12px;
      font-size: 0.8rem;
      font-weight: 600;
      border-radius: 4px 0 0 4px;
      white-space: nowrap;
      display: flex;
      align-items: center;
      flex-shrink: 0;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .input-group .command-inline-input,
    .input-group .form-input {
      border-radius: 0 4px 4px 0;
      border-left: none;
      flex: 1;
    }

    /* Special handling for name field */
    .input-group.name-field {
      flex: 3; /* Name gets more space */
    }

    .command-inline-select {
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 8px 12px;
      background: var(--surface-color);
      color: var(--text-primary);
      font-size: 0.9rem;
      min-width: auto;
      flex: none;
      width: auto;
    }

    .command-inline-input {
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 8px 12px;
      background: var(--surface-color);
      color: var(--text-primary);
      font-size: 0.9rem;
      min-width: 100px;
    }

    .command-inline-input.name {
      flex: 3;
      min-width: 150px;
    }

    .command-inline-input.code {
      flex: 2;
      min-width: 120px;
    }

    .command-inline-input.short {
      flex: 1;
      min-width: 100px;
    }

    .command-inline-color {
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 2px;
      background: var(--surface-color);
      width: 36px;
      height: 36px;
      cursor: pointer;
    }

    .command-inline-btn {
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .command-inline-btn.test {
      background: var(--primary-color);
      color: white;
    }

    .command-inline-btn.save {
      background: #4caf50;
      color: white;
    }

    .command-inline-btn.save:hover {
      background: #45a049;
    }

    .command-inline-btn.delete {
      background: transparent;
      color: #f44336;
      border: 2px solid #f44336;
      font-weight: 500;
      box-shadow: none;
      padding: 6px 8px;
      transition: all 0.2s ease;
    }
    .command-inline-btn.delete:hover {
      background: #f44336;
      color: white;
    }

    .command-inline-btn:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

  /* Button command styles to look like collapsed command-group */
  .command-button {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 20px;
      background: var(--surface-color);
      overflow: hidden;
    }

  .command-button-header {
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--surface-color);
    }

  .command-button-title {
      font-weight: 500;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Utility classes */
    .hidden {
      display: none !important;
    }

    .command-options-summary {
      padding: 6px 10px;
      background: var(--background-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 0.9rem;
      color: var(--text-secondary);
      min-width: 80px;
      text-align: center;
    }

    /* Make readonly inputs look different */
    .command-inline-input[readonly] {
      background: var(--background-color);
      color: var(--text-secondary);
      cursor: not-allowed;
    }

    .command-btn-preview.shape-rectangle {
      border-radius: 4px;
    }

    .command-btn-preview.shape-rounded {
      border-radius: 12px;
    }

    .command-btn-preview.shape-circle {
      border-radius: 50%;
      min-width: 40px;
      height: 40px;
      padding: 8px;
    }

    .command-btn-preview:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .command-toggle {
      position: relative;
      width: 50px;
      height: 24px;
      background: #ccc;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .command-toggle.on {
      background: var(--primary-color);
    }

    .command-toggle::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: transform 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .command-toggle.on::after {
      transform: translateX(26px);
    }

    .emoji-picker {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
      margin-top: 8px;
    }

    .emoji-option {
      padding: 8px;
      border: 2px solid var(--border-color);
      border-radius: 6px;
      background: var(--surface-color);
      cursor: pointer;
      text-align: center;
      font-size: 1.2rem;
      transition: all 0.3s ease;
    }

    .emoji-option:hover, .emoji-option.selected {
      border-color: var(--primary-color);
      background: var(--primary-color);
      color: white;
    }

    .props-editor {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-top: 16px;
      padding: 16px;
      background: var(--surface-color);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .props-editor-full {
      grid-column: 1 / -1;
    }

    .color-picker-wrapper {
      position: relative;
    }

    .color-picker {
      width: 100%;
      height: 40px;
      border: 2px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
    }

    .numeric-group, .string-group {
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .key-value-pair {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }

    .key-value-pair input {
      flex: 1;
    }

    .key-value-pair input:first-child {
      max-width: 80px;
    }

    .btn-remove {
      background: #f44336;
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.7rem;
    }

    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
      }
      
      .devices-grid {
        grid-template-columns: 1fr;
      }

      .props-editor {
        grid-template-columns: 1fr;
      }
    }

    /* Dark mode specific adjustments */
    @media (prefers-color-scheme: dark) {
      /* Improve scrollbar appearance in dark mode */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      
      ::-webkit-scrollbar-track {
        background: var(--surface-color);
      }
      
      ::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 4px;
      }
      
      ::-webkit-scrollbar-thumb:hover {
        background: var(--text-secondary);
      }

      /* Make badges more visible in dark mode */
      .type-ble {
        background: #1a237e;
        color: #7986cb;
      }

      .type-rf {
        background: #4a148c;
        color: #ba68c8;
      }

      .type-ir {
        background: #e65100;
        color: #ffb74d;
      }

      /* Improve notification visibility in dark mode */
      .modal {
        background: rgba(0,0,0,0.7);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🎤 Whispeer</h1>
      <div class="header-controls">
        <button class="btn" onclick="openSettingsModal()">
          ⚙️ Settings
        </button>

      </div>
    </div>

    <div id="devicesContainer">
      <div class="loading">Loading devices...</div>
    </div>
  </div>

  <!-- Device Modal (Add/Edit) -->
  <div id="deviceModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="deviceModalTitle">Configure Device</h2>
        <button class="close-btn" onclick="closeModal('deviceModal')">&times;</button>
      </div>
      <form id="deviceForm">
        <div class="command-inline-form" style="margin-bottom: 24px;">
          <select id="modalDeviceType" class="command-inline-select" style="flex: 0.8;" required onchange="onDeviceTypeChange()">
            <option value="ble">BLE</option>
            <option value="rf">RF</option>
            <option value="ir">IR</option>
          </select>
          
          <div class="input-group" style="flex: 3;">
            <div class="input-group-prepend"><span class="input-group-text">Device</span></div>
            <input type="text" id="modalDeviceName" class="form-input" placeholder="Device Name" required>
          </div>
          
          <select id="modalDeviceInterface" class="command-inline-select" style="flex: 1.2;">
            <option value="">Loading interfaces...</option>
          </select>
        </div>
      </form>
      
      <div class="commands-section" id="modalCommandsSection">
        <div class="commands-header">
          <h3>Commands</h3>
          <button type="button" class="btn btn-small" onclick="addInlineCommand()">+ Add Command</button>
        </div>
        <div class="commands-list" id="commandsList"></div>
        
        <div class="modal-controls" style="display: flex; justify-content: space-between; margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border-color);">
          <div style="display: flex; gap: 8px;">
            <button class="btn btn-outlined" type="button" onclick="discardCommandChanges()">Discard Changes</button>
            <button class="btn" id="deviceModalDeleteBtn" style="background: #f44336; color: white; display:none;" type="button">Delete Device</button>
          </div>
          <div style="display: flex; gap: 8px;">
            <button class="btn" type="submit" form="deviceForm" id="deviceModalSaveBtn">Save All</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Settings</h2>
        <button class="close-btn" onclick="closeModal('settingsModal')">&times;</button>
      </div>
      <form id="settingsForm">
        <div class="form-group">
          <label class="form-label" for="autoRefresh">Auto Refresh Interval (seconds)</label>
          <input type="number" id="autoRefresh" class="form-input" value="30" min="5" max="300">
        </div>
        <div class="form-group">
          <label class="form-label" for="maxDevices">Maximum Devices to Display</label>
          <input type="number" id="maxDevices" class="form-input" value="50" min="1" max="100">
        </div>
        <div class="controls">
          <button type="submit" class="btn">Save Settings</button>
          <button type="button" class="btn btn-secondary" onclick="closeModal('settingsModal')">Cancel</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Command Modal (Add/Edit) -->
  <div id="commandModal" class="modal">
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h2 class="modal-title" id="commandModalTitle">Add Command</h2>
        <button class="close-btn" onclick="closeModal('commandModal')">&times;</button>
      </div>
      <form id="commandForm">
        <div class="form-group">
          <label class="form-label">Command Name</label>
          <input type="text" id="commandModalName" class="form-input" required>
        </div>
        
        <div class="form-group">
          <label class="form-label">Command Type</label>
          <select id="commandModalType" class="form-select" required onchange="onCommandTypeChange()">
            <option value="button">Button - Simple button command</option>
            <option value="light">Light - On/Off toggle for lights</option>
            <option value="switch">Switch - On/Off toggle for switches</option>
            <option value="numeric">Numeric - Multiple numbered options</option>
            <option value="group">Group - Multiple named options</option>
          </select>
        </div>

  <!-- Button command fields -->
  <div id="buttonFields" class="form-group" style="display: none;">
          <label class="form-label">Command Code</label>
          <input type="text" id="commandModalCode" class="form-input" placeholder="Enter hex code">
        </div>

        <!-- Light/Switch command fields -->
        <div id="toggleFields" style="display: none;">
          <div class="form-group">
            <label class="form-label">On Command Code</label>
            <input type="text" id="commandModalOnCode" class="form-input" placeholder="Enter hex code for ON">
          </div>
          <div class="form-group">
            <label class="form-label">Off Command Code</label>
            <input type="text" id="commandModalOffCode" class="form-input" placeholder="Enter hex code for OFF">
          </div>
        </div>

        <!-- Numeric/Group command fields -->
        <div id="multiFields" style="display: none;">
          <div class="form-group">
            <label class="form-label">Options</label>
            <div id="keyValuePairs">
              <!-- Dynamic key-value pairs will be added here -->
            </div>
            <button type="button" class="btn btn-small" onclick="addKeyValuePair()">Add Option</button>
          </div>
        </div>

        <!-- Properties editor -->
        <div class="form-group">
          <label class="form-label">Appearance</label>
          <div class="props-editor">
            <div>
              <label class="form-label">Shape</label>
              <select id="commandModalShape" class="form-select">
                <option value="rectangle">Rectangle</option>
                <option value="rounded">Rounded</option>
                <option value="circle">Circle</option>
              </select>
            </div>
            <div>
              <label class="form-label">Display</label>
              <select id="commandModalDisplay" class="form-select">
                <option value="both">Icon + Name</option>
                <option value="icon">Icon Only</option>
                <option value="name">Name Only</option>
              </select>
            </div>
            <div>
              <label class="form-label">Color</label>
              <input type="color" id="commandModalColor" class="color-picker" value="#03a9f4">
            </div>
            <div>
              <label class="form-label">Icon</label>
              <div class="emoji-picker" id="emojiPicker">
                <div class="emoji-option" data-emoji="🏠">🏠</div>
                <div class="emoji-option" data-emoji="🛋️">🛋️</div>
                <div class="emoji-option" data-emoji="🛏️">🛏️</div>
                <div class="emoji-option" data-emoji="🚪">🚪</div>
                <div class="emoji-option" data-emoji="🚗">🚗</div>
                <div class="emoji-option" data-emoji="💡">💡</div>
                <div class="emoji-option" data-emoji="🖥️">🖥️</div>
                <div class="emoji-option" data-emoji="🧊">🧊</div>
                <div class="emoji-option" data-emoji="🌀">🌀</div>
                <div class="emoji-option" data-emoji="🔌">🔌</div>
              </div>
              <input type="hidden" id="commandModalIcon" value="💡">
            </div>
          </div>
        </div>

        <!-- Preview -->
        <div class="form-group">
          <label class="form-label">Preview</label>
          <div id="commandPreview" class="command-preview">
            <!-- Preview will be rendered here -->
          </div>
        </div>

        <div class="modal-controls" style="display: flex; justify-content: space-between; margin-top: 20px;">
          <button type="button" class="btn btn-outlined" onclick="closeModal('commandModal')">Cancel</button>
          <button type="submit" class="btn" style="background: #4caf50;">Save Command</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    let devices = {};
    let currentDevice = null;
    let currentCommand = null;
    let tempCommands = {};
    let settings = {
      autoRefresh: 30,
      maxDevices: 50
    };

    // Available emojis for icons
    const availableEmojis = ['🏠', '🛋️', '🛏️', '🚪', '🚗', '💡', '🖥️', '🧊', '🌀', '🔌'];

    // Command type configurations
    const commandTypes = {
      button: { label: 'Button', description: 'Simple button command' },
      light: { label: 'Light', description: 'On/Off toggle for lights' },
      switch: { label: 'Switch', description: 'On/Off toggle for switches' },
      numeric: { label: 'Numeric', description: 'Multiple numbered options' },
      group: { label: 'Group', description: 'Multiple named options' }
    };

    // Translation system removed - using hardcoded English text

    // Initialize the panel
    document.addEventListener('DOMContentLoaded', function() {
      // Debug token information
      console.log('Panel initialization - Token debug:', {
        url: window.location.href,
        hasWindowToken: !!window.homeAssistantToken,
        windowTokenLength: window.homeAssistantToken ? window.homeAssistantToken.length : 0,
        localStorageToken: localStorage.getItem('ha_access_token'),
        urlParams: new URLSearchParams(window.location.search).get('access_token')
      });
      
      loadSettings();
      loadDevices();
      startAutoRefresh();
      
      // Test token after a short delay to allow injection
      setTimeout(async () => {
        let token = getHomeAssistantToken();
        
        // If no token found, try the async method
        if (!token) {
          console.log('Trying async token retrieval...');
          token = await getTokenFromHomeAssistant();
        }
        
        if (token) {
          console.log('✅ Token available:', token.substring(0, 20) + '...');
          showSuccess('Connected to Home Assistant');
        } else {
          console.warn('❌ No token found after all attempts');
          showError('No authentication token found. You may need to manually copy your Long-Lived Access Token from Home Assistant Profile.');
          
          // Show instructions to user
          console.log('To get your token:');
          console.log('1. Go to Home Assistant Profile (click your name in bottom left)');
          console.log('2. Scroll to "Long-Lived Access Tokens"');
          console.log('3. Create a new token');
          console.log('4. Store it in browser storage with: localStorage.setItem("ha_access_token", "your_token_here")');
        }
      }, 1000);
      
      document.getElementById('deviceForm').addEventListener('submit', handleDeviceFormSubmit);
      document.getElementById('deviceModalDeleteBtn').onclick = function() {
        if (currentDevice) removeDevice(currentDevice);
      };
      
      // Command form event listener
      document.getElementById('commandForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const name = document.getElementById('commandModalName').value.trim();
        const type = document.getElementById('commandModalType').value;
        
        if (!name) {
          showError('Please provide a command name');
          return;
        }
        
        // Check if name already exists (and it's not the current command being edited)
        const currentCommands = getCurrentCommandsFromUI();
        if (currentCommands[name] && name !== currentCommand) {
          showError(`Command "${name}" already exists`);
          return;
        }
        
        const command = buildCommandFromForm(type);
        if (!command) return;
        
        // Add/update command in current UI state
        updateCommandInUI(name, command);
        
        closeModal('commandModal');
        showSuccess(`Command "${name}" ${currentCommand ? 'updated' : 'added'} successfully`);
      });
      
      // Emoji picker functionality
      document.querySelectorAll('.emoji-option').forEach(option => {
        option.addEventListener('click', function() {
          document.querySelectorAll('.emoji-option').forEach(opt => opt.classList.remove('selected'));
          this.classList.add('selected');
          document.getElementById('commandModalIcon').value = this.dataset.emoji;
          updateCommandPreview();
        });
      });
      
      // Update preview when inputs change
      ['commandModalName', 'commandModalShape', 'commandModalColor', 'commandModalDisplay'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.addEventListener('change', updateCommandPreview);
          element.addEventListener('input', updateCommandPreview);
        }
      });
      
      // Prevent Enter key from submitting the form in any input field
      document.getElementById('deviceForm').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          const target = e.target;
          
          // For all inputs, prevent form submission on Enter
          if (target.tagName === 'INPUT' || target.tagName === 'SELECT') {
            e.preventDefault();
            return;
          }
        }
      });
    });

    // Load devices from localStorage (persistent storage)
    function loadDevices() {
      const saved = localStorage.getItem('whispeerDevices');
      if (saved) {
        devices = JSON.parse(saved);
      } else {
        // Initialize with example data
        devices = {
          "office_fan": {
            "type": "ble",
            "description": "Office Fan Controller",
            "commands": {
              "all_off": "100064657252c1ae0e825bba46d94451c3b01264434804f3",
              "light_on": "100005c701c70fcd3c404b93b840d19185c8d1457459a1eb",
              "light_off": "1000b472121f5168eb450d72d6c6cf073c769715f0c404d4",
              "fan_off": "100004fc1232a1ce6ee23b8426b90431a34b3904230b0953",
              "fan_on": "1000b12ae2ac40590d68a2a861f090a7248768405588ee07",
              "fan_speed_0": "100004fc1232a1ce6ee23b8426b90431a34b3904230b0953",
              "fan_speed_1": "1000eaae7164256dc97ef250fe6356e5863624d66477db67",
              "fan_speed_2": "100006519504412f212394b58d455e8417ddfac3b2bb8eb9"
            }
          },
          "living_room_tv": {
            "type": "ir",
            "description": "Living Room TV Remote",
            "commands": {
              "power_on": "NEC:0x20DF10EF",
              "power_off": "NEC:0x20DF10EF",
              "volume_up": "NEC:0x20DF40BF",
              "volume_down": "NEC:0x20DFC03F",
              "channel_up": "NEC:0x20DF00FF",
              "channel_down": "NEC:0x20DF807F"
            }
          },
          "garage_door": {
            "type": "rf",
            "description": "Garage Door Remote",
            "commands": {
              "open": "0x123456",
              "close": "0x123457",
              "stop": "0x123458"
            }
          }
        };
        saveDevices();
      }
      
      // Sync with backend if available
      syncWithBackend();
      renderDevices();
    }

    // Sync devices with Home Assistant backend
    async function syncWithBackend() {
      try {
        const token = getHomeAssistantToken();
        if (!token) return; // Skip sync if no token
        
        const response = await fetch('/api/services/whispeer/sync_devices', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            devices: devices
          })
        });
        
        if (response.ok) {
          console.log('Devices synced with backend successfully');
        } else {
          console.warn('Failed to sync with backend:', response.statusText);
        }
      } catch (error) {
        console.warn('Backend sync failed:', error);
        // Don't show error to user as this is optional
      }
    }

    // Save devices to localStorage and sync with backend
    function saveDevices() {
      localStorage.setItem('whispeerDevices', JSON.stringify(devices));
      
      // Sync with backend in background
      syncWithBackend().catch(error => {
        console.warn('Background sync failed:', error);
      });
    }

    // Render devices in the UI
    function renderDevices() {
      const container = document.getElementById('devicesContainer');
      const deviceList = Object.entries(devices);
      
      // Create add device card
      const addDeviceCard = `
        <div class="add-device-card" onclick="openAddDeviceModal()">
          <div class="add-device-icon">➕</div>
          <div class="add-device-text">Add Device</div>
        </div>
      `;
      
      if (deviceList.length === 0) {
        container.innerHTML = `<div class="devices-grid">${addDeviceCard}</div>`;
        return;
      }

      const devicesHTML = deviceList.map(([deviceId, device]) => {
        const commands = Object.entries(device.commands || {});
        let commandsHTML = '';
        
        if (commands.length > 0) {
          commandsHTML = '<div class="device-commands">';
          
          commands.forEach(([cmdName, cmdData]) => {
            // Handle both old format (string) and new format (object)
            if (typeof cmdData === 'string') {
              // Old format - simple button
              commandsHTML += `
                <button class="btn btn-small btn-outlined" onclick="sendCommandToast('${deviceId}', '${cmdName}')">${cmdName}</button>
              `;
            } else {
              // New format - render according to type
              const { type, values = {}, props = {} } = cmdData;
              const shape = props.shape || 'rectangle';
              const color = props.color || '#03a9f4';
              const display = props.display || 'both';
              const icon = props.icon || '💡';
              
              switch (type) {
                case 'button':
                  commandsHTML += `
                    <button class="btn btn-small command-btn-preview shape-${shape}" 
                            style="background: ${color}; color: white;"
                            onclick="sendCommandToast('${deviceId}', '${cmdName}')">
                      ${display !== 'name' ? icon : ''} ${display !== 'icon' ? cmdName : ''}
                    </button>
                  `;
                  break;
                  
                case 'light':
                case 'switch':
                  commandsHTML += `
                    <div style="display: flex; align-items: center; gap: 8px; margin: 4px;">
                      <div class="command-toggle" onclick="toggleDeviceCommand('${deviceId}', '${cmdName}', '${type}')"></div>
                      <span style="color: var(--text-primary); font-size: 0.8rem;">
                        ${display !== 'icon' ? cmdName : ''} ${display !== 'name' ? icon : ''}
                      </span>
                    </div>
                  `;
                  break;
                  
                case 'numeric':
                  const numericKeys = Object.keys(values).sort((a, b) => parseInt(a) - parseInt(b));
                  numericKeys.forEach(key => {
                    commandsHTML += `
                      <button class="btn btn-small command-btn-preview shape-${shape}" 
                              style="background: ${color}; color: white;"
                              onclick="sendCommandToast('${deviceId}', '${cmdName}', '${key}')">
                        ${key}
                      </button>
                    `;
                  });
                  break;
                  
                case 'group':
                  const groupKeys = Object.keys(values);
                  groupKeys.forEach(key => {
                    commandsHTML += `
                      <button class="btn btn-small command-btn-preview shape-${shape}" 
                              style="background: ${color}; color: white;"
                              onclick="sendCommandToast('${deviceId}', '${cmdName}', '${key}')">
                        ${key}
                      </button>
                    `;
                  });
                  break;
              }
            }
          });
          
          commandsHTML += '</div>';
        } else {
          commandsHTML = `<div style="margin-top:12px;color:var(--text-secondary);font-size:0.9rem;">No commands</div>`;
        }
        
        return `
          <div class="device-card" data-device-id="${deviceId}">
            <div class="device-header">
              <div class="device-name">${deviceId}</div>
              <div class="device-header-right">
                <span class="device-type-badge type-${device.type}">${device.type.toUpperCase()}</span>
                <button class="pill-edit" onclick="configureDevice('${deviceId}')">Edit</button>
              </div>
            </div>
            ${commandsHTML}
          </div>
        `;
      }).join('');

      container.innerHTML = `<div class="devices-grid">${addDeviceCard}${devicesHTML}</div>`;
    }

    // Handle toggle commands for light/switch types
    function toggleDeviceCommand(deviceId, cmdName, type) {
      // This is a simplified toggle - you could maintain state to know if it's on/off
      showInfo(`Toggling ${type} ${cmdName}`);
      // For now, just send the 'on' command - you could enhance this to track state
      sendCommandToast(deviceId, cmdName, 'on');
    }

    // Interface management functions
    async function loadInterfaces(deviceType) {
      const interfaceSelect = document.getElementById('modalDeviceInterface');
      
      // Show loading state
      interfaceSelect.innerHTML = '<option value="">Loading interfaces...</option>';
      interfaceSelect.disabled = true;
      
      try {
        const token = getHomeAssistantToken();
        if (!token) {
          interfaceSelect.innerHTML = '<option value="">No token available</option>';
          return;
        }
        
        const endpoint = '/api/services/whispeer/get_interfaces';
        
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            type: deviceType
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          const interfaces = result.interfaces || [];
          
          // Clear loading state
          interfaceSelect.innerHTML = '';
          
          // Add default option
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = 'Auto-detect';
          interfaceSelect.appendChild(defaultOption);
          
          // Add available interfaces
          interfaces.forEach(interface => {
            const option = document.createElement('option');
            option.value = interface.id || interface.name || interface;
            option.textContent = interface.name || interface.description || interface;
            interfaceSelect.appendChild(option);
          });
          
          if (interfaces.length === 0) {
            const noInterfaceOption = document.createElement('option');
            noInterfaceOption.value = '';
            noInterfaceOption.textContent = 'No interfaces available';
            interfaceSelect.appendChild(noInterfaceOption);
          }
          
          // Restore previously selected interface if editing existing device
          if (currentDevice && devices[currentDevice].interface) {
            interfaceSelect.value = devices[currentDevice].interface;
          }
          
        } else {
          console.warn('Failed to load interfaces:', response.statusText);
          interfaceSelect.innerHTML = '<option value="">Failed to load interfaces</option>';
        }
        
      } catch (error) {
        console.error('Error loading interfaces:', error);
        interfaceSelect.innerHTML = '<option value="">Error loading interfaces</option>';
      } finally {
        interfaceSelect.disabled = false;
      }
    }
    
    function onDeviceTypeChange() {
      const deviceType = document.getElementById('modalDeviceType').value;
      loadInterfaces(deviceType);
    }

    // Device configuration functions
    function configureDevice(deviceId) {
      currentDevice = deviceId;
      const device = devices[deviceId];
      document.getElementById('deviceModalTitle').textContent = 'Edit Device';
      document.getElementById('modalDeviceName').value = deviceId;
      document.getElementById('modalDeviceName').readOnly = false; // Allow editing device name
      document.getElementById('modalDeviceType').value = device.type;
      document.getElementById('modalCommandsSection').style.display = 'block';
      document.getElementById('deviceModalDeleteBtn').style.display = 'inline-block';
      
      // Load interfaces for current device type (this will also set the interface value)
      loadInterfaces(device.type);
      
      // Ensure the device has commands object
      if (!device.commands) {
        device.commands = {};
      }
      
      renderCommands(device.commands);
      document.getElementById('deviceModal').style.display = 'block';
    }

    function renderCommands(commands) {
      const container = document.getElementById('commandsList');
      
      let html = '';
      
      // Render all existing commands as editable forms
      Object.entries(commands).forEach(([name, command]) => {
        // Handle both old format (string) and new format (object)
        let commandData;
        if (typeof command === 'string') {
          // Old format - treat as button command
          commandData = {
            name,
            type: 'button',
            values: { code: command },
            props: {
              shape: 'rectangle',
              color: '#03a9f4',
              display: 'both',
              icon: '💡'
            }
          };
        } else if (command.type && command.values) {
          // New format with values and props structure
          commandData = { name, ...command };
        } else {
          // Legacy new format - convert to new structure
          const legacyCommand = { ...command };
          // Convert old "single" type to "button" for backward compatibility
          const commandType = legacyCommand.type === 'single' ? 'button' : (legacyCommand.type || 'button');
          commandData = {
            name,
            type: commandType,
            values: {},
            props: legacyCommand.props || {
              shape: 'rectangle',
              color: '#03a9f4',
              display: 'both',
              icon: '💡'
            }
          };
          
          // Move command data to values object
          if ((commandType === 'button' || legacyCommand.type === 'single') && legacyCommand.code) {
            commandData.values.code = legacyCommand.code;
          } else if ((legacyCommand.type === 'light' || legacyCommand.type === 'switch') && (legacyCommand.on || legacyCommand.off)) {
            if (legacyCommand.on) commandData.values.on = legacyCommand.on;
            if (legacyCommand.off) commandData.values.off = legacyCommand.off;
          } else if (legacyCommand.type === 'numeric' || legacyCommand.type === 'group') {
            Object.entries(legacyCommand).forEach(([key, value]) => {
              if (!['type', 'props', 'name'].includes(key)) {
                commandData.values[key] = value;
              }
            });
          }
        }
        
        html += createInlineCommandForm(commandData, true);
      });

      if (html === '') {
        html = `<p style="text-align: center; color: var(--text-secondary); padding: 20px;">No commands configured. Click "Add Command" to get started.</p>`;
      }

      container.innerHTML = html;
    }

  function renderButtonCommand(command) {
      const { name, props = {} } = command;
      const shape = props.shape || 'rectangle';
      const color = props.color || '#03a9f4';
      const display = props.display || 'both';
      const icon = props.icon || '💡';

      const shapeEmoji = {
        rectangle: '⬜',
        circle: '🔴',
        oval: '🥚'
      };

      return `
        <div class="command-button" data-command-name="${name}">
          <div class="command-button-header">
            <div class="command-button-title">
              ${display !== 'name' ? icon : ''} 
              ${display !== 'icon' ? name : ''}
            </div>
            <div style="display: flex; gap: 4px;">
              <button type="button" class="btn-tiny btn-edit" onclick="editInlineCommand('${name}')">Edit</button>
              <button type="button" class="btn-tiny btn-delete" onclick="deleteCommand('${name}')">🗑️</button>
            </div>
          </div>
        </div>
      `;
    }

    function renderCommandGroup(type, commands) {
      const typeConfig = commandTypes[type];
      const isCollapsed = false; // Start expanded
      
      let groupHtml = `
        <div class="command-group ${isCollapsed ? 'collapsed' : ''}" data-type="${type}">
          <div class="command-group-header" onclick="toggleCommandGroup('${type}')">
            <div class="command-group-title">
              <span>${typeConfig.label} Commands</span>
              <span class="command-group-count">${commands.length}</span>
            </div>
            <span class="command-group-chevron">▼</span>
          </div>
          <div class="command-group-content">
      `;

      commands.forEach(command => {
        groupHtml += renderCommandItem(command);
      });

      groupHtml += `
          </div>
        </div>
      `;

      return groupHtml;
    }

    function renderCommandItem(command) {
      const { name, type, props = {} } = command;
      const shape = props.shape || 'rectangle';
      const color = props.color || '#03a9f4';
      const display = props.display || 'both';
      const icon = props.icon || '💡';

      let previewHtml = '';
      
      switch (type) {
  case 'button':
          previewHtml = `
            <button class="command-btn-preview shape-${shape}" 
                    style="background: ${color}; color: white;"
                    onclick="testCommand('${name}', '${command.code}')">
              ${display !== 'name' ? icon : ''} 
              ${display !== 'icon' ? name : ''}
            </button>
          `;
          break;
          
        case 'light':
        case 'switch':
          previewHtml = `
            <div class="command-toggle ${Math.random() > 0.5 ? 'on' : ''}" 
                 onclick="testToggleCommand('${name}', '${type}')"></div>
            <span style="margin-left: 8px; color: var(--text-primary);">
              ${display !== 'icon' ? name : ''} ${display !== 'name' ? icon : ''}
            </span>
          `;
          break;
          
        case 'numeric':
          const numericKeys = Object.keys(command).filter(k => !['type', 'props', 'name'].includes(k)).sort((a, b) => parseInt(a) - parseInt(b));
          previewHtml = numericKeys.map(key => `
            <button class="command-btn-preview shape-${shape}" 
                    style="background: ${color}; color: white;"
                    onclick="testCommand('${name}', '${command[key]}')">
              ${key}
            </button>
          `).join('');
          break;
          
        case 'group':
          const groupKeys = Object.keys(command).filter(k => !['type', 'props', 'name'].includes(k));
          previewHtml = groupKeys.map(key => `
            <button class="command-btn-preview shape-${shape}" 
                    style="background: ${color}; color: white;"
                    onclick="testCommand('${name}', '${command[key]}')">
              ${key}
            </button>
          `).join('');
          break;
      }

      return `
        <div class="command-item" data-command-name="${name}">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h4 style="margin: 0; color: var(--text-primary);">${name}</h4>
            <div style="display: flex; gap: 4px;">
              <button type="button" class="btn-tiny btn-edit" onclick="editCommand('${name}')">Edit</button>
              <button type="button" class="btn-tiny btn-delete" onclick="deleteCommand('${name}')">Delete</button>
            </div>
          </div>
          <div class="command-preview">
            ${previewHtml}
          </div>
        </div>
      `;
    }

    // Command modal functions
    function addInlineCommand() {
      const container = document.getElementById('commandsList');
      const formHtml = createInlineCommandForm(null, false);
      container.insertAdjacentHTML('beforeend', formHtml);
      
      // Focus on name input
      const nameInput = container.querySelector('.command-inline-form:last-child .command-inline-input[placeholder="Name"]');
      if (nameInput) nameInput.focus();
    }

    function createInlineCommandForm(command = null, isExisting = false) {
      const isEdit = !!command;
      const name = command ? command.name : '';
  const type = command ? command.type : 'button';
      const values = command ? (command.values || {}) : {};
      const code = values.code || '';
      const onCode = values.on || '';
      const offCode = values.off || '';
      const props = command ? (command.props || {}) : {};
      const shape = props.shape || 'rectangle';
      const color = props.color || '#03a9f4';
      const icon = props.icon || '💡';

      const shapeOptions = {
        rectangle: '⬜',
        circle: '🔴', 
        oval: '🥚'
      };

      let extraFields = '';
      
      // Add type-specific fields
  if (type === 'button') {
        extraFields = `
          <div class="input-group">
            <div class="input-group-prepend"><span class="input-group-text">Code</span></div>
            <input type="text" class="command-inline-input" placeholder="Hex code" value="${code}" data-field="code">
          </div>
        `;
      } else if (type === 'light' || type === 'switch' || type === 'numeric' || type === 'group') {
        // For multi-value commands, no inline fields needed
        extraFields = '';
      }

      const buttonText = isExisting ? 'Save' : 'Add';
      const deleteButton = isExisting ? 
        `<button type="button" class="command-inline-btn delete" onclick="deleteCommand('${name}')">❌</button>` :
        `<button type="button" class="command-inline-btn delete" onclick="cancelInlineCommand(this)">❌</button>`;

      let html = `
        <div class="command-container" data-command-name="${name}" data-is-existing="${isExisting}">
          <div class="command-inline-form">
            <select class="command-inline-select" onchange="onInlineTypeChange(this)" ${isExisting ? '' : ''}>
              <option value="button" ${type === 'button' ? 'selected' : ''}>Button</option>
              <option value="light" ${type === 'light' ? 'selected' : ''}>Light</option>
              <option value="switch" ${type === 'switch' ? 'selected' : ''}>Switch</option>
              <option value="numeric" ${type === 'numeric' ? 'selected' : ''}>Numeric</option>
              <option value="group" ${type === 'group' ? 'selected' : ''}>Group</option>
            </select>
            
            <div class="input-group name-field">
              <div class="input-group-prepend"><span class="input-group-text">Name</span></div>
              <input type="text" class="command-inline-input" placeholder="Name" value="${name}" ${isExisting ? '' : ''}>
            </div>
            
            ${extraFields}
            
            <select class="command-inline-select" data-field="shape">
              ${Object.entries(shapeOptions).map(([value, emoji]) => 
                `<option value="${value}" ${shape === value ? 'selected' : ''}>${emoji}</option>`
              ).join('')}
            </select>
            
            <input type="color" class="command-inline-color" value="${color}" data-field="color">
            
            <select class="command-inline-select" data-field="icon">
              ${availableEmojis.map(emoji => 
                `<option value="${emoji}" ${icon === emoji ? 'selected' : ''}>${emoji}</option>`
              ).join('')}
            </select>
            
            <button type="button" class="command-inline-btn test" onclick="testInlineCommand(this)">Test</button>
            <button type="button" class="command-inline-btn save" onclick="saveInlineCommand(this)">${buttonText}</button>
            ${deleteButton}
          </div>
      `;

      // Add options section for multi-value types
      if (type === 'light' || type === 'switch' || type === 'numeric' || type === 'group') {
        html += `
          <div class="command-options-section" data-type="${type}">
            <div class="options-list">
        `;
        
        // Add existing options
        if (command && command.values) {
          if (type === 'light' || type === 'switch') {
            // For light/switch, only show on and off fields in that order
            if (command.values.on !== undefined) {
              html += createOptionField('on', command.values.on, type);
            } else {
              html += createOptionField('on', '', type);
            }
            if (command.values.off !== undefined) {
              html += createOptionField('off', command.values.off, type);
            } else {
              html += createOptionField('off', '', type);
            }
          } else {
            // For numeric/group, show all existing options
            Object.entries(command.values).forEach(([key, value]) => {
              html += createOptionField(key, value, type);
            });
          }
        }
        
        // Add default fields if no options exist
        if (!command || !command.values || Object.keys(command.values).length === 0) {
          if (type === 'light' || type === 'switch') {
            // Add fixed ON and OFF fields
            html += createOptionField('on', '', type);
            html += createOptionField('off', '', type);
          } else {
            // Add empty field for numeric/group
            html += createOptionField('', '', type);
          }
        }
        
        html += `
            </div>
        `;
        
        // Only add "Add Option" button for numeric and group types
        if (type === 'numeric' || type === 'group') {
          html += `<button type="button" class="btn btn-small" onclick="addOptionField(this, '${type}')">+ Add Option</button>`;
        }
        
        html += `
          </div>
        `;
      }
      
      html += `</div>`;
      return html;
    }

    function createOptionField(key = '', value = '', type = 'group') {
      let placeholder = 'Name';
      let inputType = 'text';
      let keyFieldReadonly = '';
      let showDeleteButton = true;
      
      if (type === 'numeric') {
        placeholder = 'Number';
        inputType = 'number';
      } else if (type === 'light' || type === 'switch') {
        placeholder = 'State';
        keyFieldReadonly = 'readonly';
        showDeleteButton = false; // No delete button for on/off fields
      } else if (type === 'group') {
        placeholder = 'Option';
      }
      
      const deleteButton = showDeleteButton ? 
        `<button type="button" class="command-inline-btn delete" onclick="removeOptionField(this)" style="padding: 6px 8px;">❌</button>` : 
        `<span style="width: 32px;"></span>`; // Spacer to maintain alignment
      
      return `
        <div class="option-field">
          <input type="${inputType}" 
                 placeholder="${placeholder}" 
                 value="${key}" 
                 class="command-inline-input" 
                 ${inputType === 'number' ? 'min="0"' : ''}
                 ${keyFieldReadonly}
                 style="flex: 1; ${keyFieldReadonly ? 'background: var(--card-background); opacity: 0.7;' : ''}">
          <input type="text" 
                 placeholder="Command code" 
                 value="${value}" 
                 class="command-inline-input"
                 style="flex: 2;">
          ${deleteButton}
        </div>
      `;
    }

    function addOptionField(button, type) {
      const optionsList = button.closest('.command-options-section').querySelector('.options-list');
      const newField = createOptionField('', '', type);
      optionsList.insertAdjacentHTML('beforeend', newField);
      
      // Focus on the new key input
      const newInput = optionsList.querySelector('.option-field:last-child input:first-child');
      if (newInput) newInput.focus();
    }

    function removeOptionField(button) {
      const optionField = button.closest('.option-field');
      optionField.remove();
    }

    function onInlineTypeChange(select) {
      const container = select.closest('.command-container');
      const type = select.value;
      const isExisting = container.dataset.isExisting === 'true';
      const name = container.querySelector('[placeholder="Name"]').value;
      
      // Get current values
      const currentValues = {
        name: name,
        shape: container.querySelector('[data-field="shape"]').value,
        color: container.querySelector('[data-field="color"]').value,
        icon: container.querySelector('[data-field="icon"]').value
      };
      
      // For existing commands, get current data including options
      let complexData = {};
      if (isExisting && name) {
        const commands = getCurrentCommandsFromUI();
        const command = commands[name];
        if (command) {
          complexData = { ...command };
        }
      }
      
      // If changing to/from multi-value types, preserve or get options
      if (type === 'light' || type === 'switch' || type === 'numeric' || type === 'group') {
        const optionsSection = container.querySelector('.command-options-section');
        if (optionsSection) {
          // Get current options from the form
          const optionFields = optionsSection.querySelectorAll('.option-field');
          complexData.values = {};
          optionFields.forEach(field => {
            const keyInput = field.querySelector('input:first-child');
            const valueInput = field.querySelector('input:nth-child(2)');
            const key = keyInput.value.trim();
            const value = valueInput.value.trim();
            if (key && value) {
              complexData.values[key] = value;
            }
          });
        }
      }
      
      // Rebuild the form with new type
      const commandData = {
        name: currentValues.name,
        type: type,
        props: {
          shape: currentValues.shape,
          color: currentValues.color,
          icon: currentValues.icon
        },
        ...complexData
      };
      
      const newFormHtml = createInlineCommandForm(commandData, isExisting);
      container.outerHTML = newFormHtml;
    }

    function editInlineCommand(commandName) {
      const commands = getCurrentCommandsFromUI();
      const command = commands[commandName];
      
      if (!command) {
        showError('Command not found');
        return;
      }
      
      // Remove existing command display
      const existingElement = document.querySelector(`[data-command-name="${commandName}"]`);
      if (existingElement) {
        existingElement.remove();
      }
      
      // Add inline form with command data
      const container = document.getElementById('commandsList');
      const formHtml = createInlineCommandForm({ name: commandName, ...command });
      container.insertAdjacentHTML('beforeend', formHtml);
    }

    function saveInlineCommand(button) {
      const container = button.closest('.command-container');
      const form = container.querySelector('.command-inline-form');
      const isExisting = container.dataset.isExisting === 'true';
      const originalName = container.dataset.commandName;
      
      const type = form.querySelector('select').value;
      const name = form.querySelector('[placeholder="Name"]').value.trim();
      const shape = form.querySelector('[data-field="shape"]').value;
      const color = form.querySelector('[data-field="color"]').value;
      const icon = form.querySelector('[data-field="icon"]').value;
      
      if (!name) {
        showError('Please provide a command name');
        return;
      }
      
      // Check if name already exists (and it's not the current command being edited)
      const currentCommands = getCurrentCommandsFromUI();
      if (currentCommands[name] && name !== originalName) {
        showError(`Command "${name}" already exists`);
        return;
      }
      
      let command = {
        type: type,
        values: {},
        props: { shape, color, icon, display: 'both' }
      };
      
      // Get type-specific data
      if (type === 'button') {
        const code = form.querySelector('[data-field="code"]').value.trim();
        if (!code) {
          showError('Please provide a command code');
          return;
        }
        command.values.code = code;
      } else if (type === 'light' || type === 'switch' || type === 'numeric' || type === 'group') {
        // Get options from the options section
        const optionsSection = container.querySelector('.command-options-section');
        if (optionsSection) {
          const optionFields = optionsSection.querySelectorAll('.option-field');
          let hasOptions = false;
          
          optionFields.forEach(field => {
            const keyInput = field.querySelector('input:first-child');
            const valueInput = field.querySelector('input:nth-child(2)');
            const key = keyInput.value.trim();
            const value = valueInput.value.trim();
            
            if (key && value) {
              if (type === 'numeric' && isNaN(parseInt(key))) {
                showError('Numeric keys must be valid numbers');
                return;
              }
              command.values[key] = value;
              hasOptions = true;
            }
          });
          
          if (!hasOptions) {
            showError(`Please add at least one option for ${type} command`);
            return;
          }
          
          // Validate light/switch specific requirements
          if (type === 'light' || type === 'switch') {
            if (!command.values.on || !command.values.off) {
              showError('Light/Switch commands require both "on" and "off" options');
              return;
            }
          }
        }
      }
      
      // Remove old command if name changed
      if (isExisting && originalName !== name) {
        deleteCommandFromStorage(originalName);
      }
      
      // Save the command
      updateCommandInUI(name, command);
      
      // Re-render to show updates
      const commands = getCurrentCommandsFromUI();
      renderCommands(commands);
      
      showSuccess(`Command "${name}" ${isExisting ? 'updated' : 'added'} successfully`);
    }

    function cancelInlineCommand(button) {
      const container = button.closest('.command-container');
      const isExisting = container.dataset.isExisting === 'true';
      const originalName = container.dataset.commandName;
      
      if (isExisting && originalName) {
        // Restore the original command display
        const commands = getCurrentCommandsFromUI();
        renderCommands(commands);
      } else {
        // Just remove the container
        container.remove();
      }
    }

    function editComplexCommand(name, type) {
      const commands = getCurrentCommandsFromUI();
      const command = commands[name];
      
      if (!command) {
        showError('Command not found');
        return;
      }
      
      // Open the detailed modal for complex configuration
      currentCommand = name;
      document.getElementById('commandModalTitle').textContent = 'Configure Command Options';
      document.getElementById('commandModalName').value = name;
      document.getElementById('commandModalType').value = command.type;
      
      const props = command.props || {};
      document.getElementById('commandModalShape').value = props.shape || 'rectangle';
      document.getElementById('commandModalDisplay').value = props.display || 'both';
      document.getElementById('commandModalColor').value = props.color || '#03a9f4';
      document.getElementById('commandModalIcon').value = props.icon || '💡';
      
      // Clear button/toggle fields
      document.getElementById('commandModalCode').value = '';
      document.getElementById('commandModalOnCode').value = '';
      document.getElementById('commandModalOffCode').value = '';
      
      // Fill existing key-value pairs
      fillKeyValuePairs(command);
      
      // Set emoji selection
      document.querySelectorAll('.emoji-option').forEach(option => {
        option.classList.remove('selected');
      });
      document.querySelector(`[data-emoji="${props.icon || '💡'}"]`)?.classList.add('selected');
      
      onCommandTypeChange();
      updateCommandPreview();
      document.getElementById('commandModal').style.display = 'block';
    }

    function testInlineCommand(button) {
      const container = button.closest('.command-container');
      const form = container.querySelector('.command-inline-form');
      const name = form.querySelector('[placeholder="Name"]').value.trim();
      const type = form.querySelector('select').value;
      
      if (!name) {
        showError('Please provide name to test');
        return;
      }
      
      if (!currentDevice) {
        showError('Cannot test command: No device selected. Please save the device first.');
        return;
      }
      
      let code = '';
      
      if (type === 'button') {
        code = form.querySelector('[data-field="code"]').value.trim();
      } else if (type === 'light' || type === 'switch' || type === 'numeric' || type === 'group') {
        // Test with first option from the options section
        const optionsSection = container.querySelector('.command-options-section');
        if (optionsSection) {
          const firstOption = optionsSection.querySelector('.option-field input:nth-child(2)');
          if (firstOption) {
            code = firstOption.value.trim();
          }
        }
      }
      
      if (!code) {
        showError('No command code to test');
        return;
      }
      
      // Test the command
      testCommand(name, code);
    }

    function deleteCommandFromStorage(name) {
      if (currentDevice) {
        delete devices[currentDevice].commands[name];
      } else {
        delete tempCommands[name];
      }
    }

    function openDetailedCommandModal(name, command) {
      // Open the existing command modal for detailed configuration
      currentCommand = name;
      document.getElementById('commandModalTitle').textContent = 'Configure Command';
      document.getElementById('commandModalName').value = name;
      document.getElementById('commandModalType').value = command.type;
      
      const props = command.props || {};
      document.getElementById('commandModalShape').value = props.shape || 'rectangle';
      document.getElementById('commandModalDisplay').value = props.display || 'both';
      document.getElementById('commandModalColor').value = props.color || '#03a9f4';
      document.getElementById('commandModalIcon').value = props.icon || '💡';
      
      // Clear form fields
      document.getElementById('commandModalOnCode').value = '';
      document.getElementById('commandModalOffCode').value = '';
      document.getElementById('keyValuePairs').innerHTML = '';
      
      // Set emoji selection
      document.querySelectorAll('.emoji-option').forEach(option => {
        option.classList.remove('selected');
      });
      document.querySelector(`[data-emoji="${props.icon || '💡'}"]`)?.classList.add('selected');
      
      onCommandTypeChange();
      updateCommandPreview();
      document.getElementById('commandModal').style.display = 'block';
    }
    function openAddCommandModal() {
      // Use inline form instead
      addInlineCommand();
    }

    function editCommand(commandName) {
      const commands = getCurrentCommandsFromUI();
      const command = commands[commandName];
      
      if (!command) {
        showError('Command not found');
        return;
      }
      
      currentCommand = commandName;
      document.getElementById('commandModalTitle').textContent = 'Edit Command';
      document.getElementById('commandModalName').value = commandName;
      
      // Handle both old and new format
      if (typeof command === 'string') {
        // Old format
        document.getElementById('commandModalType').value = 'button';
        document.getElementById('commandModalCode').value = command;
        document.getElementById('commandModalShape').value = 'rectangle';
        document.getElementById('commandModalDisplay').value = 'both';
        document.getElementById('commandModalColor').value = '#03a9f4';
        document.getElementById('commandModalIcon').value = '💡';
      } else {
        // New format
        document.getElementById('commandModalType').value = command.type || 'button';
        
        const props = command.props || {};
        document.getElementById('commandModalShape').value = props.shape || 'rectangle';
        document.getElementById('commandModalDisplay').value = props.display || 'both';
        document.getElementById('commandModalColor').value = props.color || '#03a9f4';
        document.getElementById('commandModalIcon').value = props.icon || '💡';
        
        // Set emoji selection
        document.querySelectorAll('.emoji-option').forEach(option => {
          option.classList.remove('selected');
        });
        document.querySelector(`[data-emoji="${props.icon || '💡'}"]`)?.classList.add('selected');
        
        // Fill type-specific fields
        switch (command.type) {
          case 'button':
            document.getElementById('commandModalCode').value = command.code || '';
            break;
          case 'light':
          case 'switch':
            document.getElementById('commandModalOnCode').value = command.on || '';
            document.getElementById('commandModalOffCode').value = command.off || '';
            break;
          case 'numeric':
          case 'group':
            fillKeyValuePairs(command);
            break;
        }
      }
      
      onCommandTypeChange();
      updateCommandPreview();
      document.getElementById('commandModal').style.display = 'block';
    }

    function fillKeyValuePairs(command) {
      const container = document.getElementById('keyValuePairs');
      container.innerHTML = '';
      
      Object.entries(command).forEach(([key, value]) => {
        if (!['type', 'props', 'name'].includes(key)) {
          addKeyValuePair(key, value);
        }
      });
      
      if (container.children.length === 0) {
        addKeyValuePair();
      }
    }

    function onCommandTypeChange() {
      const type = document.getElementById('commandModalType').value;
      
      // Hide all field groups
      document.getElementById('buttonFields').style.display = 'none';
      document.getElementById('toggleFields').style.display = 'none';
      document.getElementById('multiFields').style.display = 'none';
      
      // Show relevant fields
      switch (type) {
        case 'button':
          document.getElementById('buttonFields').style.display = 'block';
          break;
        case 'light':
        case 'switch':
          document.getElementById('toggleFields').style.display = 'block';
          break;
        case 'numeric':
        case 'group':
          document.getElementById('multiFields').style.display = 'block';
          if (document.getElementById('keyValuePairs').children.length === 0) {
            addKeyValuePair();
          }
          break;
      }
      
      updateCommandPreview();
    }

    function addKeyValuePair(key = '', value = '') {
      const container = document.getElementById('keyValuePairs');
      const type = document.getElementById('commandModalType').value;
      const isNumeric = type === 'numeric';
      
      const pairDiv = document.createElement('div');
      pairDiv.className = 'key-value-pair';
      pairDiv.innerHTML = `
        <input type="${isNumeric ? 'number' : 'text'}" placeholder="${isNumeric ? 'Number' : 'Name'}" 
               value="${key}" class="form-input" ${isNumeric ? 'min="0"' : ''}>
        <input type="text" placeholder="Command code" value="${value}" class="form-input">
  <button type="button" class="btn-remove" onclick="removeKeyValuePair(this)">❌</button>
      `;
      
      container.appendChild(pairDiv);
      updateCommandPreview();
    }

    function removeKeyValuePair(button) {
      button.parentElement.remove();
      updateCommandPreview();
    }

    function updateCommandPreview() {
      const preview = document.getElementById('commandPreview');
      const type = document.getElementById('commandModalType').value;
      const name = document.getElementById('commandModalName').value || 'Command';
      const shape = document.getElementById('commandModalShape').value;
      const color = document.getElementById('commandModalColor').value;
      const display = document.getElementById('commandModalDisplay').value;
      const icon = document.getElementById('commandModalIcon').value;
      
      let previewHtml = '';
      
      switch (type) {
        case 'button':
          previewHtml = `
            <button class="command-btn-preview shape-${shape}" 
                    style="background: ${color}; color: white;">
              ${display !== 'name' ? icon : ''} 
              ${display !== 'icon' ? name : ''}
            </button>
          `;
          break;
          
        case 'light':
        case 'switch':
          previewHtml = `
            <div class="command-toggle on"></div>
            <span style="margin-left: 8px; color: var(--text-primary);">
              ${display !== 'icon' ? name : ''} ${display !== 'name' ? icon : ''}
            </span>
          `;
          break;
          
        case 'numeric':
        case 'group':
          const pairs = Array.from(document.querySelectorAll('#keyValuePairs .key-value-pair'));
          previewHtml = pairs.map(pair => {
            const keyInput = pair.querySelector('input:first-child');
            const key = keyInput.value || (type === 'numeric' ? '0' : 'Option');
            return `
              <button class="command-btn-preview shape-${shape}" 
                      style="background: ${color}; color: white;">
                ${key}
              </button>
            `;
          }).join('');
          break;
      }
      
      preview.innerHTML = previewHtml;
    }

    // Emoji picker functionality
    document.addEventListener('DOMContentLoaded', function() {
      document.querySelectorAll('.emoji-option').forEach(option => {
        option.addEventListener('click', function() {
          document.querySelectorAll('.emoji-option').forEach(opt => opt.classList.remove('selected'));
          this.classList.add('selected');
          document.getElementById('commandModalIcon').value = this.dataset.emoji;
          updateCommandPreview();
        });
      });
      
      // Update preview when inputs change
      ['commandModalName', 'commandModalShape', 'commandModalColor', 'commandModalDisplay'].forEach(id => {
        document.getElementById(id).addEventListener('change', updateCommandPreview);
        document.getElementById(id).addEventListener('input', updateCommandPreview);
      });
    });

    function toggleCommandGroup(type) {
      const group = document.querySelector(`[data-type="${type}"]`);
      group.classList.toggle('collapsed');
    }

    function testCommand(name, code) {
      if (!currentDevice) {
        showError('Cannot test command: No device selected. Please save the device first.');
        return;
      }
      
      // Create temporary command for testing
      const originalCommands = {...devices[currentDevice].commands};
      devices[currentDevice].commands[name] = code;
      
      sendCommandToast(currentDevice, name);
      
      // Restore original commands
      devices[currentDevice].commands = originalCommands;
    }

    function testToggleCommand(name, type) {
      // This would test the toggle functionality
      showInfo(`Testing ${type} toggle for ${name}`);
    }

    // Command form submit handler
    function buildCommandFromForm(type) {
      const props = {
        shape: document.getElementById('commandModalShape').value,
        color: document.getElementById('commandModalColor').value,
        display: document.getElementById('commandModalDisplay').value,
        icon: document.getElementById('commandModalIcon').value
      };
      
      let command = { type, props };
      
      switch (type) {
        case 'button':
          const code = document.getElementById('commandModalCode').value.trim();
          if (!code) {
            showError('Please provide a command code');
            return null;
          }
          command.code = code;
          break;
          
        case 'light':
        case 'switch':
          const onCode = document.getElementById('commandModalOnCode').value.trim();
          const offCode = document.getElementById('commandModalOffCode').value.trim();
          if (!onCode || !offCode) {
            showError('Please provide both ON and OFF command codes');
            return null;
          }
          command.on = onCode;
          command.off = offCode;
          break;
          
        case 'numeric':
        case 'group':
          const pairs = Array.from(document.querySelectorAll('#keyValuePairs .key-value-pair'));
          if (pairs.length === 0) {
            showError('Please add at least one option');
            return null;
          }
          
          for (const pair of pairs) {
            const keyInput = pair.querySelector('input:first-child');
            const valueInput = pair.querySelector('input:nth-child(2)');
            const key = keyInput.value.trim();
            const value = valueInput.value.trim();
            
            if (!key || !value) {
              showError('All options must have both a key and command code');
              return null;
            }
            
            if (type === 'numeric' && isNaN(parseInt(key))) {
              showError('Numeric keys must be valid numbers');
              return null;
            }
            
            command[key] = value;
          }
          break;
      }
      
      return command;
    }

    function updateCommandInUI(name, command) {
      // Remove old command if name changed
      if (currentCommand && currentCommand !== name) {
        const oldItem = document.querySelector(`[data-command-name="${currentCommand}"]`);
        if (oldItem) {
          oldItem.closest('.command-group').remove();
        }
      }
      
      // Get current commands and update
      const commands = getCurrentCommandsFromUI();
      commands[name] = command;
      
      // Re-render commands
      renderCommands(commands);
    }

    function deleteCommand(name) {
      if (confirm(`Are you sure you want to delete the command "${name}"?`)) {
        // Remove from the appropriate storage
        if (currentDevice) {
          delete devices[currentDevice].commands[name];
        } else {
          delete tempCommands[name];
        }
        
        // Re-render commands
        const commands = currentDevice ? devices[currentDevice].commands : tempCommands;
        renderCommands(commands);
        
        showSuccess(`Command "${name}" deleted successfully`);
      }
      return false;
    }

    function testCommand(name, code) {
      if (!currentDevice) {
        showError('Cannot test command: No device selected. Please save the device first.');
        return;
      }
      
      // Use the same backend call as the main command buttons
      sendCommandToast(currentDevice, name);
    }

    // Function to get current commands from the UI
    function getCurrentCommandsFromUI() {
      // During editing, we maintain the commands in memory and sync with UI
      if (currentDevice && devices[currentDevice]) {
        return { ...devices[currentDevice].commands };
      } else {
        return { ...tempCommands };
      }
    }

    // Update the command storage when saving from the command modal
    function updateCommandInUI(name, command) {
      // Store in the appropriate location
      if (currentDevice) {
        if (!devices[currentDevice].commands) {
          devices[currentDevice].commands = {};
        }
        devices[currentDevice].commands[name] = command;
      } else {
        tempCommands[name] = command;
      }
      
      // Remove old command if name changed
      if (currentCommand && currentCommand !== name) {
        if (currentDevice) {
          delete devices[currentDevice].commands[currentCommand];
        } else {
          delete tempCommands[currentCommand];
        }
      }
      
      // Re-render commands
      const commands = currentDevice ? devices[currentDevice].commands : tempCommands;
      renderCommands(commands);
    }

    // Update the delete command function to work with the new storage
    function deleteCommand(name) {
      if (confirm(`Are you sure you want to delete the command "${name}"?`)) {
        // Remove from the appropriate storage
        if (currentDevice) {
          delete devices[currentDevice].commands[name];
        } else {
          delete tempCommands[name];
        }
        
        // Re-render commands
        const commands = currentDevice ? devices[currentDevice].commands : tempCommands;
        renderCommands(commands);
        
        showSuccess(`Command "${name}" deleted successfully`);
      }
      return false;
    }

    // Enhanced function to check if there are unsaved command changes
    function hasUnsavedCommandChanges() {
      if (currentDevice) {
        // For existing devices, the commands are already updated in memory
        // So we don't really have "unsaved" changes at the command level
        return false;
      } else {
        // For new devices, check if there are any temporary commands
        return Object.keys(tempCommands).length > 0;
      }
    }

    // New functions for command management
    function discardCommandChanges() {
      if (confirm('Are you sure you want to discard all command changes?')) {
        if (currentDevice) {
          // For existing devices, we need to reload from the original saved data
          // First get the original device data from localStorage
          const saved = localStorage.getItem('whispeerDevices');
          if (saved) {
            const originalDevices = JSON.parse(saved);
            if (originalDevices[currentDevice]) {
              devices[currentDevice].commands = {...originalDevices[currentDevice].commands};
              renderCommands(devices[currentDevice].commands || {});
            }
          }
        } else {
          // Clear temporary commands for new devices
          tempCommands = {};
          renderCommands(tempCommands);
        }
        showSuccess('Command changes discarded');
      }
    }

    function openAddDeviceModal() {
      currentDevice = null;
      tempCommands = {}; // Clear any previous temp commands
      document.getElementById('deviceModalTitle').textContent = 'Add New Device';
      document.getElementById('modalDeviceName').value = '';
      document.getElementById('modalDeviceName').readOnly = false;
      document.getElementById('modalDeviceType').value = 'ble';
      document.getElementById('modalDeviceInterface').value = '';
      document.getElementById('modalCommandsSection').style.display = 'block';
      document.getElementById('deviceModalDeleteBtn').style.display = 'none';
      
      // Load interfaces for default device type (BLE)
      loadInterfaces('ble');
      
      renderCommands(tempCommands);
      document.getElementById('deviceModal').style.display = 'block';
    }

    // New functions for command management
    function discardCommandChanges() {
      if (confirm('Are you sure you want to discard all command changes?')) {
        if (currentDevice) {
          // Reload commands from saved data
          const device = devices[currentDevice];
          renderCommands(device.commands || {});
        } else {
          // Clear temporary commands for new devices
          tempCommands = {};
          renderCommands(tempCommands);
        }
        showSuccess('Command changes discarded');
      }
    }

    // Unifica el handler de guardado
    function handleDeviceFormSubmit(e) {
      e.preventDefault();
      
      const name = document.getElementById('modalDeviceName').value.trim();
      const type = document.getElementById('modalDeviceType').value;
      const interface = document.getElementById('modalDeviceInterface').value;
      if (!name || !type) {
        showError('Please provide device name and type');
        return;
      }
      
      // Get all commands from the appropriate storage
      const allCommands = getCurrentCommandsFromUI();
      
      if (!currentDevice) {
        // Nuevo dispositivo
        if (devices[name]) {
          showError(`Device "${name}" already exists`);
          return;
        }
        // Create new device with commands from tempCommands
        devices[name] = { 
          type, 
          interface, 
          commands: { ...tempCommands } // Use tempCommands for new devices
        };
        
        // Clear tempCommands after successful creation
        tempCommands = {};
        
        saveDevices();
        renderDevices();
        closeModal('deviceModal', true); // Force close without checking unsaved changes
        showSuccess(`Device "${name}" added successfully with ${Object.keys(devices[name].commands).length} commands`);
      } else {
        // Editar dispositivo existente
        devices[currentDevice].type = type;
        devices[currentDevice].interface = interface;
        // Commands are already updated in devices[currentDevice].commands through updateCommandInUI
        
        // Si el nombre cambió, actualizar
        if (name !== currentDevice) {
          if (devices[name]) {
            showError(`Device "${name}" already exists`);
            return;
          }
          devices[name] = devices[currentDevice];
          delete devices[currentDevice];
        }
        
        saveDevices();
        renderDevices();
        closeModal('deviceModal', true); // Force close without checking unsaved changes
        showSuccess(`Device "${name}" saved successfully with ${Object.keys(devices[name] ? devices[name].commands : devices[currentDevice].commands).length} commands`);
      }
    }
    document.getElementById('deviceForm').addEventListener('submit', handleDeviceFormSubmit);
    document.getElementById('deviceModalDeleteBtn').onclick = function() {
      if (currentDevice) removeDevice(currentDevice);
    };

    // Modal functions
    function openSettingsModal() {
      document.getElementById('settingsModal').style.display = 'block';
    }

    function closeModal(modalId, forceSave = false) {
      if (modalId === 'deviceModal' && !forceSave) {
        // Check if there are unsaved changes
        if (hasUnsavedChanges()) {
          if (!confirm('You have unsaved changes. Are you sure you want to close without saving?')) {
            return;
          }
        }
        // Reset temporary commands when closing
        if (!currentDevice) {
          tempCommands = {};
        }
      }
      document.getElementById(modalId).style.display = 'none';
    }

    // Function to check if there are unsaved command changes
    function hasUnsavedCommandChanges() {
      if (currentDevice) {
        // For existing devices, check if current commands differ from saved commands
        const savedCommands = devices[currentDevice].commands || {};
        const currentCommands = getCurrentCommandsFromUI();
        return JSON.stringify(savedCommands) !== JSON.stringify(currentCommands);
      } else {
        // For new devices, check if there are any temporary commands
        return Object.keys(tempCommands).length > 0;
      }
    }

    // Function to get current commands from the UI
    function getCurrentCommandsFromUI() {
      const commandItems = document.querySelectorAll('.command-item');
      const commands = {};
      
      commandItems.forEach(item => {
        const nameInput = item.querySelector('.command-name');
        const codeInput = item.querySelector('.command-code');
        if (nameInput && codeInput && nameInput.value.trim() && codeInput.value.trim()) {
          commands[nameInput.value.trim()] = codeInput.value.trim();
        }
      });
      
      return commands;
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
      if (event.target.classList.contains('modal')) {
        // Check if it's the device modal and has unsaved changes
        if (event.target.id === 'deviceModal') {
          if (hasUnsavedChanges()) {
            if (!confirm('You have unsaved changes. Are you sure you want to close without saving?')) {
              return; // Don't close the modal
            }
            // Reset temporary commands when closing without saving
            if (!currentDevice) {
              tempCommands = {};
            }
          }
        }
        event.target.style.display = 'none';
      }
    }

    // Function to check if there are unsaved changes in the device modal
    function hasUnsavedChanges() {
      // Check if device name, type, or interface has changed
      const currentName = document.getElementById('modalDeviceName').value.trim();
      const currentType = document.getElementById('modalDeviceType').value;
      const currentInterface = document.getElementById('modalDeviceInterface').value;
      
      if (currentDevice) {
        // For existing devices, check if basic info changed
        const savedInterface = devices[currentDevice].interface || '';
        if (currentName !== currentDevice || 
            devices[currentDevice].type !== currentType ||
            savedInterface !== currentInterface) {
          return true;
        }
      } else {
        // For new devices, check if any basic info is entered
        if (currentName || currentType !== 'ble' || currentInterface) {
          return true;
        }
      }
      
      // Check if there are unsaved command changes
      return hasUnsavedCommandChanges();
    }

    // Settings form handler
    document.getElementById('settingsForm').addEventListener('submit', function(e) {
      e.preventDefault();
      
      settings.autoRefresh = parseInt(document.getElementById('autoRefresh').value);
      settings.maxDevices = parseInt(document.getElementById('maxDevices').value);
      
      saveSettings();
      closeModal('settingsModal');
      showSuccess('Settings saved successfully');
      
      // Restart auto refresh with new interval
      startAutoRefresh();
    });

    // Auto refresh functionality
    let autoRefreshInterval;
    
    function startAutoRefresh() {
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
      }
      
      autoRefreshInterval = setInterval(() => {
        renderDevices();
      }, settings.autoRefresh * 1000);
    }

    // Settings management
    function loadSettings() {
      const saved = localStorage.getItem('whispeerSettings');
      if (saved) {
        settings = JSON.parse(saved);
        document.getElementById('autoRefresh').value = settings.autoRefresh;
        document.getElementById('maxDevices').value = settings.maxDevices;
      }
    }

    function saveSettings() {
      localStorage.setItem('whispeerSettings', JSON.stringify(settings));
    }

    // Utility functions
    function showSuccess(message) {
      // Simple notification - can be enhanced with proper notifications
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4caf50;
        color: white;
        padding: 12px 24px;
        border-radius: 4px;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      `;
      notification.textContent = '✅ ' + message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

    function showError(message) {
      // Simple notification - can be enhanced with proper notifications
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #f44336;
        color: white;
        padding: 12px 24px;
        border-radius: 4px;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      `;
      notification.textContent = '❌ ' + message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

    // Send command to backend
    async function sendCommandToast(deviceId, cmdName, subCommand = null) {
      const device = devices[deviceId];
      const command = device.commands[cmdName];
      
      if (!command) {
        showError(`Command "${cmdName}" not found for device "${deviceId}"`);
        return;
      }

      let commandCode;
      
      // Handle both old format (string) and new format (object)
      if (typeof command === 'string') {
        commandCode = command;
      } else {
        // New format - get the appropriate code based on command type
        switch (command.type) {
          case 'button':
          case 'single': // Backward compatibility
            commandCode = command.code;
            break;
          case 'light':
          case 'switch':
            // Use subCommand to determine on/off, default to 'on'
            commandCode = command[subCommand || 'on'];
            break;
          case 'numeric':
          case 'group':
            if (subCommand && command[subCommand]) {
              commandCode = command[subCommand];
            } else {
              showError(`Sub-command "${subCommand}" not found for "${cmdName}"`);
              return;
            }
            break;
          default:
            showError(`Unknown command type: ${command.type}`);
            return;
        }
      }
      
      if (!commandCode) {
        showError(`No command code found for "${cmdName}"`);
        return;
      }

      const token = getHomeAssistantToken();
      
      if (!token) {
        showError('No Home Assistant access token found. Panel may not be opened from Home Assistant sidebar.');
        console.error('Token debug info:', {
          url: window.location.href,
          localStorage: localStorage.getItem('ha_access_token'),
          windowToken: window.homeAssistantToken
        });
        return;
      }

      try {
        // Show loading state
        const displayName = subCommand ? `${cmdName} (${subCommand})` : cmdName;
        showInfo(`Sending "${displayName}" to "${deviceId}"...`);
        
        // Make the API call to Home Assistant
        const response = await fetch('/api/services/whispeer/send_command', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            device_id: deviceId,
            device_type: device.type,
            device_interface: device.interface || '',
            command_name: subCommand ? `${cmdName}_${subCommand}` : cmdName,
            command_code: commandCode
          })
        });

        if (response.ok) {
          const result = await response.json();
          showSuccess(`Command "${displayName}" sent successfully to "${deviceId}"`);
          console.log('Command sent successfully:', result);
        } else if (response.status === 401) {
          // Handle unauthorized specifically
          showError(`Unauthorized (401): Token may be expired or invalid. Please refresh the page from Home Assistant.`);
          console.error('Authorization failed. Token info:', {
            tokenLength: token ? token.length : 0,
            tokenStart: token ? token.substring(0, 10) + '...' : 'null',
            responseStatus: response.status
          });
          // Clear invalid token
          localStorage.removeItem('ha_access_token');
        } else {
          const errorData = await response.json();
          showError(`Failed to send command (${response.status}): ${errorData.message || response.statusText}`);
          console.error('Command failed:', errorData);
        }
      } catch (error) {
        console.error('Error sending command:', error);
        showError(`Network error: ${error.message}`);
      }
    }

    // Remove device function
    async function removeDevice(deviceId) {
      if (!confirm(`Are you sure you want to delete device "${deviceId}"?`)) {
        return;
      }
      
      try {
        // Get device info before deleting (for potential backend notification)
        const deviceToDelete = devices[deviceId];
        
        // Remove from local storage first
        delete devices[deviceId];
        saveDevices();
        
        const token = getHomeAssistantToken();
        
        // Try to notify backend (optional - backend might not need this)
        if (token && deviceToDelete) {
          try {
            await fetch('/api/services/whispeer/remove_device', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
              },
              body: JSON.stringify({
                device_id: deviceId,
                device_type: deviceToDelete.type,
                device_interface: deviceToDelete.interface || ''
              })
            });
          } catch (backendError) {
            console.warn('Failed to notify backend of device removal:', backendError);
            // Don't show error to user as local removal succeeded
          }
        }
        
        // Clear currentDevice if it was the deleted device
        if (currentDevice === deviceId) {
          currentDevice = null;
        }
        
        renderDevices();
        closeModal('deviceModal');
        showSuccess(`Device "${deviceId}" removed successfully`);
        
      } catch (error) {
        console.error('Error removing device:', error);
        showError(`Failed to remove device: ${error.message}`);
      }
    }

    // Get Home Assistant token from multiple sources
    function getHomeAssistantToken() {
      // First check if we have the injected function from backend
      if (window.getHomeAssistantToken && window.getHomeAssistantToken !== getHomeAssistantToken) {
        const backendToken = window.getHomeAssistantToken();
        if (backendToken) {
          return backendToken;
        }
      }
      
      // Try to get token from URL parameters first (when opened from HA)
      const urlParams = new URLSearchParams(window.location.search);
      const tokenFromUrl = urlParams.get('access_token');
      
      if (tokenFromUrl) {
        localStorage.setItem('ha_access_token', tokenFromUrl);
        return tokenFromUrl;
      }
      
      // Try from global variable set by backend
      if (window.homeAssistantToken && window.homeAssistantToken !== '') {
        localStorage.setItem('ha_access_token', window.homeAssistantToken);
        return window.homeAssistantToken;
      }
      
      // Fallback to stored token
      const storedToken = localStorage.getItem('ha_access_token');
      if (storedToken && storedToken !== 'undefined' && storedToken !== '') {
        return storedToken;
      }
      
      // Try to get from parent window (if in iframe)
      try {
        if (window.parent && window.parent !== window) {
          // Try to access parent window's Home Assistant context
          const parentHA = window.parent.document?.querySelector('home-assistant');
          if (parentHA && parentHA.hass && parentHA.hass.auth) {
            const token = parentHA.hass.auth.accessToken;
            if (token) {
              localStorage.setItem('ha_access_token', token);
              return token;
            }
          }
        }
      } catch (e) {
        console.debug('Cannot access parent window Home Assistant context:', e);
      }
      
      // Last resort: try to create a dummy request to get auth headers
      try {
        // This approach works when the panel is loaded within Home Assistant's context
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/', false); // Synchronous request
        xhr.send();
        const authHeader = xhr.getResponseHeader('Authorization');
        if (authHeader && authHeader.startsWith('Bearer ')) {
          const token = authHeader.substring(7);
          localStorage.setItem('ha_access_token', token);
          return token;
        }
      } catch (e) {
        console.debug('Cannot extract token from API headers:', e);
      }
      
      // No token available
      console.error('No Home Assistant access token found');
      return null;
    }

    // Add info notification function
    function showInfo(message) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--primary-color);
        color: white;
        padding: 12px 24px;
        border-radius: 4px;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      `;
      notification.textContent = 'ℹ️ ' + message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 2000);
    }
    async function getTokenFromHomeAssistant() {
      try {
        // Try to make a simple request to get the current user's token info
        const response = await fetch('/api/auth/current_user', {
          method: 'GET',
          credentials: 'include'
        });
        
        if (response.ok) {
          const userData = await response.json();
          console.log('Current user data:', userData);
          // The actual token will be in the session/cookies, not the response
          // But this confirms we're authenticated
          
          // Try to get the token from the session storage or other location
          const sessionToken = sessionStorage.getItem('hassTokens') || localStorage.getItem('hassTokens');
          if (sessionToken) {
            const tokens = JSON.parse(sessionToken);
            if (tokens.access_token) {
              localStorage.setItem('ha_access_token', tokens.access_token);
              return tokens.access_token;
            }
          }
        }
      } catch (error) {
        console.debug('Cannot get token from Home Assistant API:', error);
      }
      
      return null;
    }
    function showInfo(message) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--primary-color);
        color: white;
        padding: 12px 24px;
        border-radius: 4px;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      `;
      notification.textContent = 'ℹ️ ' + message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 2000);
    }
  </script>
</body>
</html>
