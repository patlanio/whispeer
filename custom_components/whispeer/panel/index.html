<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Whispeer Control Panel</title>
  <style>
    :root {
      --primary-color: #03a9f4;
      --primary-dark: #0288d1;
      --secondary-color: #ff9800;
      --background-color: #fafafa;
      --surface-color: #ffffff;
      --text-primary: #212121;
      --text-secondary: #757575;
      --border-color: #e0e0e0;
      --shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* Dark theme - follows system preference automatically */
    @media (prefers-color-scheme: dark) {
      :root {
        --primary-color: #4fc3f7;
        --primary-dark: #29b6f6;
        --secondary-color: #ffb74d;
        --background-color: #121212;
        --surface-color: #1e1e1e;
        --text-primary: #ffffff;
        --text-secondary: #b0b0b0;
        --border-color: #333333;
        --shadow: 0 2px 4px rgba(0,0,0,0.3);
      }
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background-color: var(--background-color);
      color: var(--text-primary);
      line-height: 1.6;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      background: var(--surface-color);
      border: 1px solid var(--border-color);
      padding: 16px 24px;
      border-radius: 8px;
      margin-bottom: 24px;
      box-shadow: var(--shadow);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header h1 {
      font-size: 1.8rem;
      font-weight: 400;
      margin: 0;
      color: var(--text-primary);
    }

    .header-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .btn {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-secondary {
      background: var(--secondary-color);
    }

    .btn-secondary:hover {
      background: #f57c00;
    }

    .btn-small {
      padding: 8px 16px;
      font-size: 0.8rem;
      border-radius: 4px;
    }

    .btn-outlined {
      background: transparent;
      color: var(--primary-color);
      border: 2px solid var(--primary-color);
      box-shadow: none;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .btn-outlined:hover {
      background: var(--primary-color);
      color: white;
    }

    #languageSelector {
      background: var(--primary-color);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 500;
      text-transform: none;
      letter-spacing: normal;
    }

    #languageSelector:hover {
      background: var(--primary-dark);
    }

    .devices-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }

    .device-card {
      background: var(--surface-color);
      border-radius: 8px;
      padding: 20px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
    }

    .add-device-card {
      background: var(--surface-color);
      border-radius: 8px;
      padding: 20px;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      border: 2px dashed var(--border-color);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 120px;
      text-align: center;
      color: var(--text-secondary);
    }

    .add-device-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border-color: var(--primary-color);
      background: var(--background-color);
    }

    /* Dark mode specific hover effect */
    @media (prefers-color-scheme: dark) {
      .add-device-card:hover {
        background: #2a2a2a;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      }
    }

    .add-device-icon {
      font-size: 3rem;
      margin-bottom: 12px;
      color: var(--primary-color);
    }

    .device-commands {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .device-commands .btn {
      flex: 1;
      min-width: fit-content;
      text-align: center;
      white-space: nowrap;
    }

    .device-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 16px;
    }

    .device-header-right {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
    }

    .device-name {
      font-size: 1.2rem;
      font-weight: 500;
      color: var(--text-primary);
    }

    .device-type-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .type-ble {
      background: #e3f2fd;
      color: #1976d2;
    }

    .type-rf {
      background: #f3e5f5;
      color: #7b1fa2;
    }

    .type-ir {
      background: #fff3e0;
      color: #f57c00;
    }

    .device-info {
      color: var(--text-secondary);
      font-size: 0.9rem;
      margin-bottom: 16px;
    }

    .device-actions {
      display: flex;
      gap: 8px;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: var(--text-secondary);
    }

    .loading::after {
      content: '';
      width: 40px;
      height: 40px;
      border: 3px solid var(--border-color);
      border-top: 3px solid var(--primary-color);
      border-radius: 50%;
      display: inline-block;
      animation: spin 1s linear infinite;
      margin-top: 16px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }

    .empty-state h3 {
      font-size: 1.5rem;
      margin-bottom: 16px;
      color: var(--text-primary);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
    }

    .modal-content {
      background: var(--surface-color);
      margin: 2% auto;
      padding: 24px;
      border-radius: 8px;
      width: 90%;
      max-width: 90vw;
      min-width: 300px;
      height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-title {
      font-size: 1.5rem;
      font-weight: 500;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-secondary);
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--text-primary);
    }

    /* Unify all modal input styles, including command add/edit fields */
    .form-input, .form-select, .command-name, .command-code {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--border-color);
      border-radius: 6px;
      font-size: 0.9rem;
      transition: border-color 0.3s ease;
      background: var(--surface-color);
      color: var(--text-primary);
      box-sizing: border-box;
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    .form-input:focus, .form-select:focus, .command-name:focus, .command-code:focus {
      outline: none;
      border-color: var(--primary-color);
    }
    .command-name {
      min-width: 120px;
      max-width: 150px;
      font-weight: 500;
      border-radius: 6px;
      background: var(--surface-color);
      font-size: 0.9rem;
    }
    /* Add command form inputs */
    #addCommandForm input[type="text"] {
      border-radius: 6px;
      background: var(--surface-color);
      font-size: 0.9rem;
      color: var(--text-primary);
      border: 2px solid var(--border-color);
      padding: 12px;
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    #addCommandForm input[type="text"]:focus {
      border-color: var(--primary-color);
      outline: none;
    }

    .commands-section {
      margin-top: 20px;
      padding: 20px;
      background: var(--background-color);
      border-radius: 8px;
    }

    .commands-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .commands-list {
      /* max-height: 40vh; */
      overflow-y: auto;
    }

    .command-item {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 8px 12px;
      background: var(--surface-color);
      border-radius: 4px;
      margin-bottom: 8px;
      border: 1px solid var(--border-color);
    }

    .command-name {
      font-weight: 500;
      min-width: 120px;
    }

    .command-code {
      font-family: monospace;
      font-size: 0.8rem;
      color: var(--text-secondary);
      flex: 1;
      /* padding: 4px 8px; */
      border-radius: 3px;
      word-break: break-all;
    }

    .command-actions {
      display: flex;
      gap: 4px;
    }

    .btn-tiny {
      padding: 4px 8px;
      font-size: 0.7rem;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-edit {
      background: var(--secondary-color);
      color: white;
    }

    .btn-delete {
      background: #f44336;
      color: white;
    }

    .btn-test {
      background: var(--primary-color);
      color: white;
    }

    .command-form {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
    }

    .command-form input {
      flex: 1;
    }

    .command-form input:first-child {
      max-width: 150px;
    }

    .pill-edit {
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 4px 16px;
      font-size: 0.8rem;
      font-weight: 500;
      margin-left: 8px;
      cursor: pointer;
      transition: background 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }
    .pill-edit:hover {
      background: var(--primary-dark);
    }

    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
      }
      
      .devices-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Dark mode specific adjustments */
    @media (prefers-color-scheme: dark) {
      /* Improve scrollbar appearance in dark mode */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      
      ::-webkit-scrollbar-track {
        background: var(--surface-color);
      }
      
      ::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 4px;
      }
      
      ::-webkit-scrollbar-thumb:hover {
        background: var(--text-secondary);
      }

      /* Make badges more visible in dark mode */
      .type-ble {
        background: #1a237e;
        color: #7986cb;
      }

      .type-rf {
        background: #4a148c;
        color: #ba68c8;
      }

      .type-ir {
        background: #e65100;
        color: #ffb74d;
      }

      /* Improve notification visibility in dark mode */
      .modal {
        background: rgba(0,0,0,0.7);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé§ Whispeer</h1>
      <div class="header-controls">
        <button class="btn" onclick="openSettingsModal()">
          ‚öôÔ∏è Settings
        </button>
        <select id="languageSelector" class="btn" style="padding: 10px;" onchange="changeLanguage(this.value)">
          <option value="en">üá∫üá∏ English</option>
          <option value="es">üá≤üáΩ Espa√±ol</option>
          <option value="fr">üá´üá∑ Fran√ßais</option>
        </select>
      </div>
    </div>

    <div id="devicesContainer">
      <div class="loading">Loading devices...</div>
    </div>
  </div>

  <!-- Device Modal (Add/Edit) -->
  <div id="deviceModal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
      <div class="modal-header">
        <h2 class="modal-title" id="deviceModalTitle">Configurar Dispositivo</h2>
        <button class="close-btn" onclick="closeModal('deviceModal')">&times;</button>
      </div>
      <form id="deviceForm">
        <div class="form-group">
          <label class="form-label">Device Name</label>
          <input type="text" id="modalDeviceName" class="form-input" required>
        </div>
        <div class="form-group" style="display: flex; gap: 16px;">
          <div style="flex: 1;">
            <label class="form-label">Device Type</label>
            <select id="modalDeviceType" class="form-select" required onchange="onDeviceTypeChange()">
              <option value="ble">BLE (Bluetooth Low Energy)</option>
              <option value="rf">RF (Radio Frequency)</option>
              <option value="ir">IR (Infrared)</option>
            </select>
          </div>
          <div style="flex: 1;" id="interfaceGroup">
            <label class="form-label">Interface</label>
            <select id="modalDeviceInterface" class="form-select">
              <option value="">Loading interfaces...</option>
            </select>
          </div>
        </div>
        <div class="commands-section" id="modalCommandsSection">
          <div class="commands-header">
            <h3>Commands</h3>
          </div>
          <div class="commands-list" id="commandsList"></div>
          <div id="addCommandForm" class="command-form" style="display: flex; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color);">
            <input type="text" id="commandName" placeholder="Command name (e.g., light_on)">
            <input type="text" id="commandCode" placeholder="Command code (hex)">
            <button class="btn btn-small" type="button" onclick="addCommand()">Add</button>
          </div>
        </div>
        <div class="modal-controls" style="display: flex; justify-content: space-between; margin-top: 20px;">
          <div style="display: flex; gap: 8px;">
            <button class="btn btn-outlined" type="button" onclick="discardCommandChanges()">Discard Changes</button>
            <button class="btn" id="deviceModalDeleteBtn" style="background: #f44336; color: white; display:none;" type="button">Delete Device</button>
          </div>
          <div style="display: flex; gap: 8px;">
            <button class="btn" type="submit" id="deviceModalSaveBtn">Save All</button>
          </div>
        </div>
      </form>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Settings</h2>
        <button class="close-btn" onclick="closeModal('settingsModal')">&times;</button>
      </div>
      <form id="settingsForm">
        <div class="form-group">
          <label class="form-label" for="autoRefresh">Auto Refresh Interval (seconds)</label>
          <input type="number" id="autoRefresh" class="form-input" value="30" min="5" max="300">
        </div>
        <div class="form-group">
          <label class="form-label" for="maxDevices">Maximum Devices to Display</label>
          <input type="number" id="maxDevices" class="form-input" value="50" min="1" max="100">
        </div>
        <div class="controls">
          <button type="submit" class="btn">Save Settings</button>
          <button type="button" class="btn btn-secondary" onclick="closeModal('settingsModal')">Cancel</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    let devices = {};
    let currentDevice = null;
    let tempCommands = {};
    let settings = {
      autoRefresh: 30,
      maxDevices: 50
    };

    // Translation system
    const translations = {
      en: {
        title: "Whispeer",
        buttons: {
          addDevice: "Add Device",
          settings: "Settings",
          save: "Save",
          cancel: "Cancel",
          delete: "Delete",
          edit: "Edit",
          add: "Add",
          test: "Test",
          saveCommands: "Save Commands",
          discardChanges: "Discard Changes",
          saveDevice: "Save Device",
          deleteDevice: "Delete Device",
          saveAll: "Save All"
        },
        labels: {
          deviceName: "Device Name",
          deviceType: "Device Type",
          interface: "Interface",
          commands: "Commands",
          autoRefresh: "Auto Refresh Interval (seconds)",
          maxDevices: "Maximum Devices to Display"
        },
        placeholders: {
          commandName: "Command name (e.g., light_on)",
          commandCode: "Command code (hex)"
        },
        messages: {
          loadingDevices: "Loading devices...",
          noCommandsConfigured: "No commands configured",
          noCommands: "No commands"
        },
        modals: {
          configureDevice: "Configure Device",
          addNewDevice: "Add New Device",
          editDevice: "Edit Device",
          settings: "Settings"
        },
        deviceTypes: {
          ble: "BLE (Bluetooth Low Energy)",
          rf: "RF (Radio Frequency)",
          ir: "IR (Infrared)"
        }
      },
      es: {
        title: "Whispeer",
        buttons: {
          addDevice: "Agregar Dispositivo",
          settings: "Configuraci√≥n",
          save: "Guardar",
          cancel: "Cancelar",
          delete: "Eliminar",
          edit: "Editar",
          add: "Agregar",
          test: "Probar",
          saveCommands: "Guardar Comandos",
          discardChanges: "Descartar Cambios",
          saveDevice: "Guardar Dispositivo",
          deleteDevice: "Eliminar Dispositivo",
          saveAll: "Guardar Todo"
        },
        labels: {
          deviceName: "Nombre del Dispositivo",
          deviceType: "Tipo de Dispositivo",
          interface: "Interfaz",
          commands: "Comandos",
          autoRefresh: "Intervalo de Actualizaci√≥n Autom√°tica (segundos)",
          maxDevices: "M√°ximo de Dispositivos a Mostrar"
        },
        placeholders: {
          commandName: "Nombre del comando (ej. encender_luz)",
          commandCode: "C√≥digo del comando (hex)"
        },
        messages: {
          loadingDevices: "Cargando dispositivos...",
          noCommandsConfigured: "No hay comandos configurados",
          noCommands: "Sin comandos"
        },
        modals: {
          configureDevice: "Configurar Dispositivo",
          addNewDevice: "Agregar Nuevo Dispositivo",
          editDevice: "Editar Dispositivo",
          settings: "Configuraci√≥n"
        },
        deviceTypes: {
          ble: "BLE (Bluetooth de Baja Energ√≠a)",
          rf: "RF (Radiofrecuencia)",
          ir: "IR (Infrarrojo)"
        }
      },
      fr: {
        title: "Whispeer",
        buttons: {
          addDevice: "Ajouter un Appareil",
          settings: "Param√®tres",
          save: "Sauvegarder",
          cancel: "Annuler",
          delete: "Supprimer",
          edit: "Modifier",
          add: "Ajouter",
          test: "Tester",
          saveCommands: "Sauvegarder les Commandes",
          discardChanges: "Annuler les Modifications",
          saveDevice: "Sauvegarder l'Appareil",
          deleteDevice: "Supprimer l'Appareil",
          saveAll: "Tout Sauvegarder"
        },
        labels: {
          deviceName: "Nom de l'Appareil",
          deviceType: "Type d'Appareil",
          interface: "Interface",
          commands: "Commandes",
          autoRefresh: "Intervalle de Rafra√Æchissement Automatique (secondes)",
          maxDevices: "Nombre Maximum d'Appareils √† Afficher"
        },
        placeholders: {
          commandName: "Nom de la commande (ex. allumer_lumiere)",
          commandCode: "Code de la commande (hex)"
        },
        messages: {
          loadingDevices: "Chargement des appareils...",
          noCommandsConfigured: "Aucune commande configur√©e",
          noCommands: "Aucune commande"
        },
        modals: {
          configureDevice: "Configurer l'Appareil",
          addNewDevice: "Ajouter un Nouvel Appareil",
          editDevice: "Modifier l'Appareil",
          settings: "Param√®tres"
        },
        deviceTypes: {
          ble: "BLE (Bluetooth Basse Consommation)",
          rf: "RF (Radiofr√©quence)",
          ir: "IR (Infrarouge)"
        }
      }
    };

    let currentLanguage = 'en';

    // Translation function
    function t(key) {
      const keys = key.split('.');
      let value = translations[currentLanguage];
      for (const k of keys) {
        value = value?.[k];
      }
      return value || key;
    }

    // Change language function
    function changeLanguage(lang) {
      if (translations[lang]) {
        currentLanguage = lang;
        localStorage.setItem('whispeerLanguage', lang);
        updateUILanguage();
      }
    }

    // Update UI with current language
    function updateUILanguage() {
      // Update header
      document.querySelector('.header h1').textContent = `üé§ ${t('title')}`;
      
      // Update settings button in header
      document.querySelector('.header-controls button[onclick="openSettingsModal()"]').innerHTML = `‚öôÔ∏è ${t('buttons.settings')}`;
      
      // Update modal elements
      updateModalLanguage();
      
      // Re-render devices to update text
      renderDevices();
    }

    function updateModalLanguage() {
      // Device modal labels
      const deviceNameLabel = document.querySelector('label[for="modalDeviceName"], .form-label');
      if (deviceNameLabel) deviceNameLabel.textContent = t('labels.deviceName');
      
      const deviceTypeLabel = document.querySelectorAll('.form-label')[1];
      if (deviceTypeLabel) deviceTypeLabel.textContent = t('labels.deviceType');
      
      const interfaceLabel = document.querySelectorAll('.form-label')[2];
      if (interfaceLabel) interfaceLabel.textContent = t('labels.interface');
      
      // Settings modal
      const autoRefreshLabel = document.querySelector('label[for="autoRefresh"]');
      if (autoRefreshLabel) autoRefreshLabel.textContent = t('labels.autoRefresh');
      
      const maxDevicesLabel = document.querySelector('label[for="maxDevices"]');
      if (maxDevicesLabel) maxDevicesLabel.textContent = t('labels.maxDevices');
      
      // Modal buttons - New command buttons
      const discardChangesBtn = document.querySelector('button[onclick="discardCommandChanges()"]');
      if (discardChangesBtn) discardChangesBtn.textContent = t('buttons.discardChanges');
      
      const saveDeviceBtn = document.getElementById('deviceModalSaveBtn');
      if (saveDeviceBtn) saveDeviceBtn.textContent = t('buttons.saveAll');
      
      const deleteDeviceBtn = document.getElementById('deviceModalDeleteBtn');
      if (deleteDeviceBtn) deleteDeviceBtn.textContent = t('buttons.deleteDevice');
      
      // Form placeholders
      const commandNameInput = document.getElementById('commandName');
      if (commandNameInput) commandNameInput.placeholder = t('placeholders.commandName');
      
      const commandCodeInput = document.getElementById('commandCode');
      if (commandCodeInput) commandCodeInput.placeholder = t('placeholders.commandCode');
      
      // Settings form buttons
      const settingsSaveBtn = document.querySelector('#settingsForm button[type="submit"]');
      if (settingsSaveBtn) settingsSaveBtn.textContent = t('buttons.save');
      
      const settingsCancelBtn = document.querySelector('button[onclick="closeModal(\'settingsModal\')"]');
      if (settingsCancelBtn) settingsCancelBtn.textContent = t('buttons.cancel');
    }

    // Initialize the panel
    document.addEventListener('DOMContentLoaded', function() {
      // Debug token information
      console.log('Panel initialization - Token debug:', {
        url: window.location.href,
        hasWindowToken: !!window.homeAssistantToken,
        windowTokenLength: window.homeAssistantToken ? window.homeAssistantToken.length : 0,
        localStorageToken: localStorage.getItem('ha_access_token'),
        urlParams: new URLSearchParams(window.location.search).get('access_token')
      });
      
      // Load saved language
      const savedLanguage = localStorage.getItem('whispeerLanguage');
      if (savedLanguage && translations[savedLanguage]) {
        currentLanguage = savedLanguage;
        document.getElementById('languageSelector').value = savedLanguage;
      }
      
      loadSettings();
      loadDevices();
      startAutoRefresh();
      updateUILanguage(); // Apply translations
      
      // Test token after a short delay to allow injection
      setTimeout(async () => {
        let token = getHomeAssistantToken();
        
        // If no token found, try the async method
        if (!token) {
          console.log('Trying async token retrieval...');
          token = await getTokenFromHomeAssistant();
        }
        
        if (token) {
          console.log('‚úÖ Token available:', token.substring(0, 20) + '...');
          showSuccess('Connected to Home Assistant');
        } else {
          console.warn('‚ùå No token found after all attempts');
          showError('No authentication token found. You may need to manually copy your Long-Lived Access Token from Home Assistant Profile.');
          
          // Show instructions to user
          console.log('To get your token:');
          console.log('1. Go to Home Assistant Profile (click your name in bottom left)');
          console.log('2. Scroll to "Long-Lived Access Tokens"');
          console.log('3. Create a new token');
          console.log('4. Store it in browser storage with: localStorage.setItem("ha_access_token", "your_token_here")');
        }
      }, 1000);
      
      document.getElementById('deviceForm').addEventListener('submit', handleDeviceFormSubmit);
      document.getElementById('deviceModalDeleteBtn').onclick = function() {
        if (currentDevice) removeDevice(currentDevice);
      };
      
      // Prevent Enter key from submitting the form in any input field
      document.getElementById('deviceForm').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          const target = e.target;
          
          // If Enter is pressed in command form inputs (add new command section), add the command
          if (target.id === 'commandName' || target.id === 'commandCode') {
            e.preventDefault();
            addCommand();
            return;
          }
          
          // If Enter is pressed in existing command inputs, test the command
          if (target.classList.contains('command-name') || target.classList.contains('command-code')) {
            e.preventDefault();
            const commandItem = target.closest('.command-item');
            if (commandItem) {
              const testButton = commandItem.querySelector('.btn-test');
              if (testButton) {
                testCommandFromButton(testButton);
              }
            }
            return;
          }
          
          // For all other inputs, prevent form submission
          if (target.tagName === 'INPUT' || target.tagName === 'SELECT') {
            e.preventDefault();
            return;
          }
        }
      });
    });

    // Load devices from localStorage (persistent storage)
    function loadDevices() {
      const saved = localStorage.getItem('whispeerDevices');
      if (saved) {
        devices = JSON.parse(saved);
      } else {
        // Initialize with example data
        devices = {
          "office_fan": {
            "type": "ble",
            "description": "Office Fan Controller",
            "commands": {
              "all_off": "100064657252c1ae0e825bba46d94451c3b01264434804f3",
              "light_on": "100005c701c70fcd3c404b93b840d19185c8d1457459a1eb",
              "light_off": "1000b472121f5168eb450d72d6c6cf073c769715f0c404d4",
              "fan_off": "100004fc1232a1ce6ee23b8426b90431a34b3904230b0953",
              "fan_on": "1000b12ae2ac40590d68a2a861f090a7248768405588ee07",
              "fan_speed_0": "100004fc1232a1ce6ee23b8426b90431a34b3904230b0953",
              "fan_speed_1": "1000eaae7164256dc97ef250fe6356e5863624d66477db67",
              "fan_speed_2": "100006519504412f212394b58d455e8417ddfac3b2bb8eb9"
            }
          },
          "living_room_tv": {
            "type": "ir",
            "description": "Living Room TV Remote",
            "commands": {
              "power_on": "NEC:0x20DF10EF",
              "power_off": "NEC:0x20DF10EF",
              "volume_up": "NEC:0x20DF40BF",
              "volume_down": "NEC:0x20DFC03F",
              "channel_up": "NEC:0x20DF00FF",
              "channel_down": "NEC:0x20DF807F"
            }
          },
          "garage_door": {
            "type": "rf",
            "description": "Garage Door Remote",
            "commands": {
              "open": "0x123456",
              "close": "0x123457",
              "stop": "0x123458"
            }
          }
        };
        saveDevices();
      }
      
      // Sync with backend if available
      syncWithBackend();
      renderDevices();
    }

    // Sync devices with Home Assistant backend
    async function syncWithBackend() {
      try {
        const token = getHomeAssistantToken();
        if (!token) return; // Skip sync if no token
        
        const response = await fetch('/api/services/whispeer/sync_devices', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            devices: devices
          })
        });
        
        if (response.ok) {
          console.log('Devices synced with backend successfully');
        } else {
          console.warn('Failed to sync with backend:', response.statusText);
        }
      } catch (error) {
        console.warn('Backend sync failed:', error);
        // Don't show error to user as this is optional
      }
    }

    // Save devices to localStorage and sync with backend
    function saveDevices() {
      localStorage.setItem('whispeerDevices', JSON.stringify(devices));
      
      // Sync with backend in background
      syncWithBackend().catch(error => {
        console.warn('Background sync failed:', error);
      });
    }

    // Render devices in the UI
    function renderDevices() {
      const container = document.getElementById('devicesContainer');
      const deviceList = Object.entries(devices);
      
      // Create add device card
      const addDeviceCard = `
        <div class="add-device-card" onclick="openAddDeviceModal()">
          <div class="add-device-icon">‚ûï</div>
          <div class="add-device-text">${t('buttons.addDevice')}</div>
        </div>
      `;
      
      if (deviceList.length === 0) {
        container.innerHTML = `<div class="devices-grid">${addDeviceCard}</div>`;
        return;
      }

      const devicesHTML = deviceList.map(([deviceId, device]) => {
        const commands = Object.entries(device.commands || {});
        const commandsHTML = commands.length > 0
          ? `<div class="device-commands">
              ${commands.map(([cmdName, cmdCode]) => `
                <button class="btn btn-small btn-outlined" onclick="sendCommandToast('${deviceId}', '${cmdName}')">${cmdName}</button>
              `).join('')}
            </div>`
          : `<div style="margin-top:12px;color:var(--text-secondary);font-size:0.9rem;">${t('messages.noCommands')}</div>`;
        return `
          <div class="device-card" data-device-id="${deviceId}">
            <div class="device-header">
              <div class="device-name">${deviceId}</div>
              <div class="device-header-right">
                <span class="device-type-badge type-${device.type}">${device.type.toUpperCase()}</span>
                <button class="pill-edit" onclick="configureDevice('${deviceId}')">${t('buttons.edit')}</button>
              </div>
            </div>
            ${commandsHTML}
          </div>
        `;
      }).join('');

      container.innerHTML = `<div class="devices-grid">${addDeviceCard}${devicesHTML}</div>`;
    }

    // Interface management functions
    async function loadInterfaces(deviceType) {
      const interfaceSelect = document.getElementById('modalDeviceInterface');
      const interfaceGroup = document.getElementById('interfaceGroup');
      
      // Show loading state
      interfaceSelect.innerHTML = '<option value="">Loading interfaces...</option>';
      interfaceSelect.disabled = true;
      
      try {
        const token = getHomeAssistantToken();
        if (!token) {
          interfaceSelect.innerHTML = '<option value="">No token available</option>';
          return;
        }
        
        const endpoint = '/api/services/whispeer/get_interfaces';
        
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            type: deviceType
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          const interfaces = result.interfaces || [];
          
          // Clear loading state
          interfaceSelect.innerHTML = '';
          
          // Add default option
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = 'Auto-detect';
          interfaceSelect.appendChild(defaultOption);
          
          // Add available interfaces
          interfaces.forEach(interface => {
            const option = document.createElement('option');
            option.value = interface.id || interface.name || interface;
            option.textContent = interface.name || interface.description || interface;
            interfaceSelect.appendChild(option);
          });
          
          if (interfaces.length === 0) {
            const noInterfaceOption = document.createElement('option');
            noInterfaceOption.value = '';
            noInterfaceOption.textContent = 'No interfaces available';
            interfaceSelect.appendChild(noInterfaceOption);
          }
          
          // Restore previously selected interface if editing existing device
          if (currentDevice && devices[currentDevice].interface) {
            interfaceSelect.value = devices[currentDevice].interface;
          }
          
        } else {
          console.warn('Failed to load interfaces:', response.statusText);
          interfaceSelect.innerHTML = '<option value="">Failed to load interfaces</option>';
        }
        
      } catch (error) {
        console.error('Error loading interfaces:', error);
        interfaceSelect.innerHTML = '<option value="">Error loading interfaces</option>';
      } finally {
        interfaceSelect.disabled = false;
      }
    }
    
    function onDeviceTypeChange() {
      const deviceType = document.getElementById('modalDeviceType').value;
      loadInterfaces(deviceType);
    }

    // Device configuration functions
    function configureDevice(deviceId) {
      currentDevice = deviceId;
      const device = devices[deviceId];
      document.getElementById('deviceModalTitle').textContent = t('modals.editDevice');
      document.getElementById('modalDeviceName').value = deviceId;
      document.getElementById('modalDeviceName').readOnly = true;
      document.getElementById('modalDeviceType').value = device.type;
      document.getElementById('modalCommandsSection').style.display = 'block';
      document.getElementById('deviceModalDeleteBtn').style.display = 'inline-block';
      
      // Load interfaces for current device type (this will also set the interface value)
      loadInterfaces(device.type);
      
      renderCommands(device.commands || {});
      updateModalLanguage(); // Update modal language
      document.getElementById('deviceModal').style.display = 'block';
    }

    function renderCommands(commands) {
      const container = document.getElementById('commandsList');
      const commandEntries = Object.entries(commands);
      if (commandEntries.length === 0) {
        container.innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('messages.noCommandsConfigured')}</p>`;
        return;
      }
      const commandsHTML = commandEntries.map(([name, code]) => `
        <div class="command-item" data-command-name="${name}">
          <input class="command-name form-input" value="${name}" onchange="updateCommandName(this, '${name}')" style="min-width:120px;max-width:150px;">
          <input class="command-code form-input" value="${code}" onchange="updateCommandCode('${name}', this.value)" style="flex:1;">
          <div class="command-actions">
            <button type="button" class="btn-tiny btn-test" onclick="event.preventDefault(); event.stopPropagation(); testCommandFromButton(this); return false;">${t('buttons.test')}</button>
            <button type="button" class="btn-tiny btn-delete" onclick="event.preventDefault(); event.stopPropagation(); deleteCommand('${name}'); return false;">${t('buttons.delete')}</button>
          </div>
        </div>
      `).join('');
      container.innerHTML = commandsHTML;
    }

    function updateCommandName(input, oldName) {
      const newName = input.value.trim();
      if (!newName || newName === oldName) return;
      
      // Check if new name already exists in the UI
      const allCommandNames = Array.from(document.querySelectorAll('.command-name'))
        .map(inp => inp.value.trim())
        .filter(name => name !== oldName);
      
      if (allCommandNames.includes(newName)) {
        showError(`Command name "${newName}" already exists.`);
        input.value = oldName;
        return;
      }
      
      // The name change is handled directly in the UI
      // It will be collected when saving the device
    }

    function updateCommandCode(name, newCode) {
      // Commands are now updated directly in the UI
      // They will be collected when saving the device
    }

    function addCommand() {
      const name = document.getElementById('commandName').value.trim();
      const code = document.getElementById('commandCode').value.trim();
      if (!name || !code) {
        showError('Please provide both command name and code');
        return;
      }
      
      // Check if command name already exists in the UI
      const existingNames = Array.from(document.querySelectorAll('.command-name'))
        .map(inp => inp.value.trim());
      
      if (existingNames.includes(name)) {
        if (!confirm(`Command "${name}" already exists. Do you want to overwrite it?`)) {
          return;
        }
        // Remove existing command from UI
        const existingItem = document.querySelector(`[data-command-name="${name}"]`);
        if (existingItem) {
          existingItem.remove();
        }
      }
      
      // Add the new command to the UI
      const container = document.getElementById('commandsList');
      const commandHTML = `
        <div class="command-item" data-command-name="${name}">
          <input class="command-name form-input" value="${name}" onchange="updateCommandName(this, '${name}')" style="min-width:120px;max-width:150px;">
          <input class="command-code form-input" value="${code}" onchange="updateCommandCode('${name}', this.value)" style="flex:1;">
          <div class="command-actions">
            <button type="button" class="btn-tiny btn-test" onclick="event.preventDefault(); event.stopPropagation(); testCommandFromButton(this); return false;">${t('buttons.test')}</button>
            <button type="button" class="btn-tiny btn-delete" onclick="event.preventDefault(); event.stopPropagation(); deleteCommand('${name}'); return false;">${t('buttons.delete')}</button>
          </div>
        </div>
      `;
      
      // If container only has the "no commands" message, replace it
      if (container.innerHTML.includes('No commands configured') || container.innerHTML.includes('noCommandsConfigured')) {
        container.innerHTML = commandHTML;
      } else {
        container.insertAdjacentHTML('beforeend', commandHTML);
      }
      
      // Clear the form fields
      document.getElementById('commandName').value = '';
      document.getElementById('commandCode').value = '';
      showSuccess(`Command "${name}" added successfully`);
    }

    function deleteCommand(name) {
      // Prevent any form submission or default behavior
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      
      if (confirm(`Are you sure you want to delete the command "${name}"?`)) {
        // Remove the command item from the UI
        const commandItem = document.querySelector(`[data-command-name="${name}"]`);
        if (commandItem) {
          commandItem.remove();
        }
        
        // Check if no commands left, show message
        const commandsList = document.getElementById('commandsList');
        const remainingCommands = commandsList.querySelectorAll('.command-item');
        if (remainingCommands.length === 0) {
          commandsList.innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('messages.noCommandsConfigured')}</p>`;
        }
        
        showSuccess(`Command "${name}" deleted successfully`);
      }
      return false;
    }

    function testCommand(name, code) {
      if (!currentDevice) {
        showError('Cannot test command: No device selected. Please save the device first.');
        return;
      }
      
      // Use the same backend call as the main command buttons
      sendCommandToast(currentDevice, name);
    }

    // New function to handle test button clicks with proper code retrieval
    function testCommandFromButton(button) {
      const commandItem = button.closest('.command-item');
      const nameInput = commandItem.querySelector('.command-name');
      const codeInput = commandItem.querySelector('.command-code');
      
      const name = nameInput.value.trim();
      const code = codeInput.value.trim();
      
      if (!name || !code) {
        showError('Please provide both command name and code before testing');
        return false;
      }
      
      if (!currentDevice) {
        showError('Cannot test command: No device selected. Please save the device first.');
        return false;
      }
      
      // Create a temporary command object to test
      const tempTestCommands = {[name]: code};
      
      // Temporarily add the command to the device to test it
      const originalCommands = {...devices[currentDevice].commands};
      devices[currentDevice].commands[name] = code;
      
      // Test the command
      sendCommandToast(currentDevice, name);
      
      // Restore original commands
      devices[currentDevice].commands = originalCommands;
      
      return false;
    }

    function openAddDeviceModal() {
      currentDevice = null;
      tempCommands = {};
      document.getElementById('deviceModalTitle').textContent = t('modals.addNewDevice');
      document.getElementById('modalDeviceName').value = '';
      document.getElementById('modalDeviceName').readOnly = false;
      document.getElementById('modalDeviceType').value = 'ble';
      document.getElementById('modalDeviceInterface').value = '';
      document.getElementById('modalCommandsSection').style.display = 'block';
      document.getElementById('deviceModalDeleteBtn').style.display = 'none';
      
      // Load interfaces for default device type (BLE)
      loadInterfaces('ble');
      
      renderCommands(tempCommands);
      updateModalLanguage(); // Update modal language
      document.getElementById('deviceModal').style.display = 'block';
    }

    // New functions for command management
    function discardCommandChanges() {
      if (confirm('Are you sure you want to discard all command changes?')) {
        if (currentDevice) {
          // Reload commands from saved data
          const device = devices[currentDevice];
          renderCommands(device.commands || {});
        } else {
          // Clear temporary commands for new devices
          tempCommands = {};
          renderCommands(tempCommands);
        }
        showSuccess('Command changes discarded');
      }
    }

    // Unifica el handler de guardado
    function handleDeviceFormSubmit(e) {
      e.preventDefault();
      const name = document.getElementById('modalDeviceName').value.trim();
      const type = document.getElementById('modalDeviceType').value;
      const interface = document.getElementById('modalDeviceInterface').value;
      if (!name || !type) {
        showError('Please provide device name and type');
        return;
      }
      
      // Get all commands from the UI (including any changes made)
      const allCommands = getCurrentCommandsFromUI();
      
      if (!currentDevice) {
        // Nuevo dispositivo
        if (devices[name]) {
          showError(`Device "${name}" already exists`);
          return;
        }
        devices[name] = { type, interface, commands: allCommands };
        saveDevices();
        renderDevices();
        closeModal('deviceModal');
        showSuccess(`Device "${name}" added successfully with ${Object.keys(allCommands).length} commands`);
      } else {
        // Editar dispositivo existente
        devices[currentDevice].type = type;
        devices[currentDevice].interface = interface;
        devices[currentDevice].commands = allCommands;
        
        // Si el nombre cambi√≥, actualizar
        if (name !== currentDevice) {
          if (devices[name]) {
            showError(`Device "${name}" already exists`);
            return;
          }
          devices[name] = devices[currentDevice];
          delete devices[currentDevice];
        }
        
        saveDevices();
        renderDevices();
        closeModal('deviceModal');
        showSuccess(`Device "${name}" saved successfully with ${Object.keys(allCommands).length} commands`);
      }
    }
    document.getElementById('deviceForm').addEventListener('submit', handleDeviceFormSubmit);
    document.getElementById('deviceModalDeleteBtn').onclick = function() {
      if (currentDevice) removeDevice(currentDevice);
    };

    // Modal functions
    function openSettingsModal() {
      document.getElementById('settingsModal').style.display = 'block';
    }

    function closeModal(modalId) {
      if (modalId === 'deviceModal') {
        // Check if there are unsaved changes
        if (hasUnsavedChanges()) {
          if (!confirm('You have unsaved changes. Are you sure you want to close without saving?')) {
            return;
          }
        }
        // Reset temporary commands when closing
        if (!currentDevice) {
          tempCommands = {};
        }
      }
      document.getElementById(modalId).style.display = 'none';
    }

    // Function to check if there are unsaved command changes
    function hasUnsavedCommandChanges() {
      if (currentDevice) {
        // For existing devices, check if current commands differ from saved commands
        const savedCommands = devices[currentDevice].commands || {};
        const currentCommands = getCurrentCommandsFromUI();
        return JSON.stringify(savedCommands) !== JSON.stringify(currentCommands);
      } else {
        // For new devices, check if there are any temporary commands
        return Object.keys(tempCommands).length > 0;
      }
    }

    // Function to get current commands from the UI
    function getCurrentCommandsFromUI() {
      const commandItems = document.querySelectorAll('.command-item');
      const commands = {};
      
      commandItems.forEach(item => {
        const nameInput = item.querySelector('.command-name');
        const codeInput = item.querySelector('.command-code');
        if (nameInput && codeInput && nameInput.value.trim() && codeInput.value.trim()) {
          commands[nameInput.value.trim()] = codeInput.value.trim();
        }
      });
      
      return commands;
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
      if (event.target.classList.contains('modal')) {
        // Check if it's the device modal and has unsaved changes
        if (event.target.id === 'deviceModal') {
          if (hasUnsavedChanges()) {
            if (!confirm('You have unsaved changes. Are you sure you want to close without saving?')) {
              return; // Don't close the modal
            }
            // Reset temporary commands when closing without saving
            if (!currentDevice) {
              tempCommands = {};
            }
          }
        }
        event.target.style.display = 'none';
      }
    }

    // Function to check if there are unsaved changes in the device modal
    function hasUnsavedChanges() {
      // Check if device name, type, or interface has changed
      const currentName = document.getElementById('modalDeviceName').value.trim();
      const currentType = document.getElementById('modalDeviceType').value;
      const currentInterface = document.getElementById('modalDeviceInterface').value;
      
      if (currentDevice) {
        // For existing devices, check if basic info changed
        const savedInterface = devices[currentDevice].interface || '';
        if (currentName !== currentDevice || 
            devices[currentDevice].type !== currentType ||
            savedInterface !== currentInterface) {
          return true;
        }
      } else {
        // For new devices, check if any basic info is entered
        if (currentName || currentType !== 'ble' || currentInterface) {
          return true;
        }
      }
      
      // Check if there are unsaved command changes
      return hasUnsavedCommandChanges();
    }

    // Settings form handler
    document.getElementById('settingsForm').addEventListener('submit', function(e) {
      e.preventDefault();
      
      settings.autoRefresh = parseInt(document.getElementById('autoRefresh').value);
      settings.maxDevices = parseInt(document.getElementById('maxDevices').value);
      
      saveSettings();
      closeModal('settingsModal');
      showSuccess('Settings saved successfully');
      
      // Restart auto refresh with new interval
      startAutoRefresh();
    });

    // Auto refresh functionality
    let autoRefreshInterval;
    
    function startAutoRefresh() {
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
      }
      
      autoRefreshInterval = setInterval(() => {
        renderDevices();
      }, settings.autoRefresh * 1000);
    }

    // Settings management
    function loadSettings() {
      const saved = localStorage.getItem('whispeerSettings');
      if (saved) {
        settings = JSON.parse(saved);
        document.getElementById('autoRefresh').value = settings.autoRefresh;
        document.getElementById('maxDevices').value = settings.maxDevices;
      }
    }

    function saveSettings() {
      localStorage.setItem('whispeerSettings', JSON.stringify(settings));
    }

    // Utility functions
    function showSuccess(message) {
      // Simple notification - can be enhanced with proper notifications
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4caf50;
        color: white;
        padding: 12px 24px;
        border-radius: 4px;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      `;
      notification.textContent = '‚úÖ ' + message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

    function showError(message) {
      // Simple notification - can be enhanced with proper notifications
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #f44336;
        color: white;
        padding: 12px 24px;
        border-radius: 4px;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      `;
      notification.textContent = '‚ùå ' + message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

    // Send command to backend
    async function sendCommandToast(deviceId, cmdName) {
      const device = devices[deviceId];
      const commandCode = device.commands[cmdName];
      
      if (!commandCode) {
        showError(`Command "${cmdName}" not found for device "${deviceId}"`);
        return;
      }

      const token = getHomeAssistantToken();
      
      if (!token) {
        showError('No Home Assistant access token found. Panel may not be opened from Home Assistant sidebar.');
        console.error('Token debug info:', {
          url: window.location.href,
          localStorage: localStorage.getItem('ha_access_token'),
          windowToken: window.homeAssistantToken
        });
        return;
      }

      try {
        // Show loading state
        showInfo(`Sending "${cmdName}" to "${deviceId}"...`);
        
        // Make the API call to Home Assistant
        const response = await fetch('/api/services/whispeer/send_command', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            device_id: deviceId,
            device_type: device.type,
            device_interface: device.interface || '',
            command_name: cmdName,
            command_code: commandCode
          })
        });

        if (response.ok) {
          const result = await response.json();
          showSuccess(`Command "${cmdName}" sent successfully to "${deviceId}"`);
          console.log('Command sent successfully:', result);
        } else if (response.status === 401) {
          // Handle unauthorized specifically
          showError(`Unauthorized (401): Token may be expired or invalid. Please refresh the page from Home Assistant.`);
          console.error('Authorization failed. Token info:', {
            tokenLength: token ? token.length : 0,
            tokenStart: token ? token.substring(0, 10) + '...' : 'null',
            responseStatus: response.status
          });
          // Clear invalid token
          localStorage.removeItem('ha_access_token');
        } else {
          const errorData = await response.json();
          showError(`Failed to send command (${response.status}): ${errorData.message || response.statusText}`);
          console.error('Command failed:', errorData);
        }
      } catch (error) {
        console.error('Error sending command:', error);
        showError(`Network error: ${error.message}`);
      }
    }

    // Remove device function
    async function removeDevice(deviceId) {
      if (!confirm(`Are you sure you want to delete device "${deviceId}"?`)) {
        return;
      }
      
      try {
        // Remove from local storage first
        delete devices[deviceId];
        saveDevices();
        
        const token = getHomeAssistantToken();
        
        // Try to notify backend (optional - backend might not need this)
        if (token) {
          try {
            await fetch('/api/services/whispeer/remove_device', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
              },
              body: JSON.stringify({
                device_id: deviceId
              })
            });
          } catch (backendError) {
            console.warn('Failed to notify backend of device removal:', backendError);
            // Don't show error to user as local removal succeeded
          }
        }
        
        renderDevices();
        closeModal('deviceModal');
        showSuccess(`Device "${deviceId}" removed successfully`);
        
      } catch (error) {
        console.error('Error removing device:', error);
        showError(`Failed to remove device: ${error.message}`);
      }
    }

    // Get Home Assistant token from multiple sources
    function getHomeAssistantToken() {
      // First check if we have the injected function from backend
      if (window.getHomeAssistantToken && window.getHomeAssistantToken !== getHomeAssistantToken) {
        const backendToken = window.getHomeAssistantToken();
        if (backendToken) {
          return backendToken;
        }
      }
      
      // Try to get token from URL parameters first (when opened from HA)
      const urlParams = new URLSearchParams(window.location.search);
      const tokenFromUrl = urlParams.get('access_token');
      
      if (tokenFromUrl) {
        localStorage.setItem('ha_access_token', tokenFromUrl);
        return tokenFromUrl;
      }
      
      // Try from global variable set by backend
      if (window.homeAssistantToken && window.homeAssistantToken !== '') {
        localStorage.setItem('ha_access_token', window.homeAssistantToken);
        return window.homeAssistantToken;
      }
      
      // Fallback to stored token
      const storedToken = localStorage.getItem('ha_access_token');
      if (storedToken && storedToken !== 'undefined' && storedToken !== '') {
        return storedToken;
      }
      
      // Try to get from parent window (if in iframe)
      try {
        if (window.parent && window.parent !== window) {
          // Try to access parent window's Home Assistant context
          const parentHA = window.parent.document?.querySelector('home-assistant');
          if (parentHA && parentHA.hass && parentHA.hass.auth) {
            const token = parentHA.hass.auth.accessToken;
            if (token) {
              localStorage.setItem('ha_access_token', token);
              return token;
            }
          }
        }
      } catch (e) {
        console.debug('Cannot access parent window Home Assistant context:', e);
      }
      
      // Last resort: try to create a dummy request to get auth headers
      try {
        // This approach works when the panel is loaded within Home Assistant's context
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/', false); // Synchronous request
        xhr.send();
        const authHeader = xhr.getResponseHeader('Authorization');
        if (authHeader && authHeader.startsWith('Bearer ')) {
          const token = authHeader.substring(7);
          localStorage.setItem('ha_access_token', token);
          return token;
        }
      } catch (e) {
        console.debug('Cannot extract token from API headers:', e);
      }
      
      // No token available
      console.error('No Home Assistant access token found');
      return null;
    }

    // Add info notification function
    function showInfo(message) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--primary-color);
        color: white;
        padding: 12px 24px;
        border-radius: 4px;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      `;
      notification.textContent = '‚ÑπÔ∏è ' + message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 2000);
    }
    async function getTokenFromHomeAssistant() {
      try {
        // Try to make a simple request to get the current user's token info
        const response = await fetch('/api/auth/current_user', {
          method: 'GET',
          credentials: 'include'
        });
        
        if (response.ok) {
          const userData = await response.json();
          console.log('Current user data:', userData);
          // The actual token will be in the session/cookies, not the response
          // But this confirms we're authenticated
          
          // Try to get the token from the session storage or other location
          const sessionToken = sessionStorage.getItem('hassTokens') || localStorage.getItem('hassTokens');
          if (sessionToken) {
            const tokens = JSON.parse(sessionToken);
            if (tokens.access_token) {
              localStorage.setItem('ha_access_token', tokens.access_token);
              return tokens.access_token;
            }
          }
        }
      } catch (error) {
        console.debug('Cannot get token from Home Assistant API:', error);
      }
      
      return null;
    }
    function showInfo(message) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--primary-color);
        color: white;
        padding: 12px 24px;
        border-radius: 4px;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      `;
      notification.textContent = '‚ÑπÔ∏è ' + message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 2000);
    }
  </script>
</body>
</html>
